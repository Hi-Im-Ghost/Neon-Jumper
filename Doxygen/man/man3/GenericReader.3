.TH "GenericReader< SourceEncoding, TargetEncoding, StackAllocator >" 3 "Fri Jan 14 2022" "Version 1.0.0" "Neon Jumper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
GenericReader< SourceEncoding, TargetEncoding, StackAllocator > \- SAX-style JSON parser\&. Use \fBReader\fP for \fBUTF8\fP encoding and default allocator\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <reader\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef SourceEncoding::Ch \fBCh\fP"
.br
.RI "SourceEncoding character type\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGenericReader\fP (StackAllocator *stackAllocator=0, size_t stackCapacity=kDefaultStackCapacity)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "template<unsigned parseFlags, typename InputStream , typename \fBHandler\fP > \fBParseResult\fP \fBParse\fP (InputStream &is, \fBHandler\fP &handler)"
.br
.RI "Parse JSON text\&. "
.ti -1c
.RI "template<typename InputStream , typename \fBHandler\fP > \fBParseResult\fP \fBParse\fP (InputStream &is, \fBHandler\fP &handler)"
.br
.RI "Parse JSON text (with \fBkParseDefaultFlags\fP) "
.ti -1c
.RI "void \fBIterativeParseInit\fP ()"
.br
.RI "Initialize JSON text token-by-token parsing\&. "
.ti -1c
.RI "template<unsigned parseFlags, typename InputStream , typename \fBHandler\fP > bool \fBIterativeParseNext\fP (InputStream &is, \fBHandler\fP &handler)"
.br
.RI "Parse one token from JSON text\&. "
.ti -1c
.RI "RAPIDJSON_FORCEINLINE bool \fBIterativeParseComplete\fP () const"
.br
.RI "Check if token-by-token parsing JSON text is complete\&. "
.ti -1c
.RI "bool \fBHasParseError\fP () const"
.br
.RI "Whether a parse error has occurred in the last parsing\&. "
.ti -1c
.RI "\fBParseErrorCode\fP \fBGetParseErrorCode\fP () const"
.br
.RI "Get the \fBParseErrorCode\fP of last parsing\&. "
.ti -1c
.RI "size_t \fBGetErrorOffset\fP () const"
.br
.RI "Get the position of last parsing error in input, 0 otherwise\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBSetParseError\fP (\fBParseErrorCode\fP code, size_t offset)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename SourceEncoding, typename TargetEncoding, typename StackAllocator = CrtAllocator>
.br
class GenericReader< SourceEncoding, TargetEncoding, StackAllocator >"SAX-style JSON parser\&. Use \fBReader\fP for \fBUTF8\fP encoding and default allocator\&. 

\fBGenericReader\fP parses JSON text from a stream, and send events synchronously to an object implementing Handler concept\&.
.PP
It needs to allocate a stack for storing a single decoded string during non-destructive parsing\&.
.PP
For in-situ parsing, the decoded string is directly written to the source text string, no temporary buffer is required\&.
.PP
A \fBGenericReader\fP object can be reused for parsing multiple JSON text\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fISourceEncoding\fP Encoding of the input stream\&. 
.br
\fITargetEncoding\fP Encoding of the parse output\&. 
.br
\fIStackAllocator\fP Allocator type for stack\&. 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> typedef SourceEncoding::Ch \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::Ch"

.PP
SourceEncoding character type\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >\fB::GenericReader\fP (StackAllocator * stackAllocator = \fC0\fP, size_t stackCapacity = \fCkDefaultStackCapacity\fP)\fC [inline]\fP"

.PP
Constructor\&. 
.PP
\fBParameters\fP
.RS 4
\fIstackAllocator\fP Optional allocator for allocating stack memory\&. (Only use for non-destructive parsing) 
.br
\fIstackCapacity\fP stack capacity in bytes for storing a single decoded string\&. (Only use for non-destructive parsing) 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> size_t \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::GetErrorOffset () const\fC [inline]\fP"

.PP
Get the position of last parsing error in input, 0 otherwise\&. 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> \fBParseErrorCode\fP \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::GetParseErrorCode () const\fC [inline]\fP"

.PP
Get the \fBParseErrorCode\fP of last parsing\&. 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> bool \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::HasParseError () const\fC [inline]\fP"

.PP
Whether a parse error has occurred in the last parsing\&. 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> RAPIDJSON_FORCEINLINE bool \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::IterativeParseComplete () const\fC [inline]\fP"

.PP
Check if token-by-token parsing JSON text is complete\&. 
.PP
\fBReturns\fP
.RS 4
Whether the JSON has been fully decoded\&. 
.RE
.PP

.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> void \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::IterativeParseInit ()\fC [inline]\fP"

.PP
Initialize JSON text token-by-token parsing\&. 
.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> template<unsigned parseFlags, typename InputStream , typename \fBHandler\fP > bool \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::IterativeParseNext (InputStream & is, \fBHandler\fP & handler)\fC [inline]\fP"

.PP
Parse one token from JSON text\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIInputStream\fP Type of input stream, implementing Stream concept 
.br
\fIHandler\fP Type of handler, implementing Handler concept\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIis\fP Input stream to be parsed\&. 
.br
\fIhandler\fP The handler to receive events\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether the parsing is successful\&. 
.RE
.PP

.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> template<unsigned parseFlags, typename InputStream , typename \fBHandler\fP > \fBParseResult\fP \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::Parse (InputStream & is, \fBHandler\fP & handler)\fC [inline]\fP"

.PP
Parse JSON text\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIparseFlags\fP Combination of \fBParseFlag\fP\&. 
.br
\fIInputStream\fP Type of input stream, implementing Stream concept\&. 
.br
\fIHandler\fP Type of handler, implementing Handler concept\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIis\fP Input stream to be parsed\&. 
.br
\fIhandler\fP The handler to receive events\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether the parsing is successful\&. 
.RE
.PP

.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> template<typename InputStream , typename \fBHandler\fP > \fBParseResult\fP \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::Parse (InputStream & is, \fBHandler\fP & handler)\fC [inline]\fP"

.PP
Parse JSON text (with \fBkParseDefaultFlags\fP) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIInputStream\fP Type of input stream, implementing Stream concept 
.br
\fIHandler\fP Type of handler, implementing Handler concept\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIis\fP Input stream to be parsed\&. 
.br
\fIhandler\fP The handler to receive events\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether the parsing is successful\&. 
.RE
.PP

.SS "template<typename SourceEncoding , typename TargetEncoding , typename StackAllocator  = CrtAllocator> void \fBGenericReader\fP< SourceEncoding, TargetEncoding, StackAllocator >::SetParseError (\fBParseErrorCode\fP code, size_t offset)\fC [inline]\fP, \fC [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Neon Jumper from the source code\&.
