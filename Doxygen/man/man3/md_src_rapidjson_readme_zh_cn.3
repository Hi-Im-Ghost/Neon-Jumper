.TH "md_src_rapidjson_readme_zh_cn" 3 "Fri Jan 21 2022" "Neon Jumper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_src_rapidjson_readme_zh_cn \- readme\&.zh-cn 

.PP
.SS "高效的 C++ JSON 解析／生成器，提供 SAX 及 DOM 风格 API"
Tencent is pleased to support the open source community by making RapidJSON available\&.
.PP
Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip\&.
.PP
.IP "\(bu" 2
\fCRapidJSON GitHub\fP
.IP "\(bu" 2
RapidJSON 文档
.IP "  \(bu" 4
\fCEnglish\fP
.IP "  \(bu" 4
\fC简体中文\fP
.IP "  \(bu" 4
\fCGitBook\fP 可下载 PDF/EPUB/MOBI，但不含 API 参考手册。
.PP

.PP
.SS "Build 状态"
\fCLinux\fP   \fCWindows\fP   \fCCoveralls\fP             
.SS "简介"
RapidJSON 是一个 C++ 的 JSON 解析器及生成器。它的灵感来自 \fCRapidXml\fP。
.PP
.IP "\(bu" 2
RapidJSON 小而全。它同时支持 SAX 和 DOM 风格的 API。SAX 解析器只有约 500 行代码。
.IP "\(bu" 2
RapidJSON 快。它的性能可与 \fCstrlen()\fP 相比。可支持 SSE2/SSE4\&.2 加速。
.IP "\(bu" 2
RapidJSON 独立。它不依赖于 BOOST 等外部库。它甚至不依赖于 STL。
.IP "\(bu" 2
RapidJSON 对内存友好。在大部分 32/64 位机器上，每个 JSON 值只占 16 字节（除字符串外）。它预设使用一个快速的内存分配器，令分析器可以紧凑地分配内存。
.IP "\(bu" 2
RapidJSON 对 Unicode 友好。它支持 UTF-8、UTF-16、UTF-32 (大端序／小端序)，并内部支持这些编码的检测、校验及转码。例如，RapidJSON 可以在分析一个 UTF-8 文件至 DOM 时，把当中的 JSON 字符串转码至 UTF-16。它也支持代理对（surrogate pair）及 \fC'\\u0000'\fP（空字符）。
.PP
.PP
在 \fBC:/Users/R2-D2/Desktop/STUDIA/Semestr\fP 5/Podstawy grafiki komputerowej/Projekt/Neon Jumper/src/rapidjson/doc/features\&.zh-cn\&.md '这里' 可读取更多特点。
.PP
JSON（JavaScript Object Notation）是一个轻量的数据交换格式。RapidJSON 应该完全遵从 RFC7159/ECMA-404，并支持可选的放宽语法。 关于 JSON 的更多信息可参考：
.IP "\(bu" 2
\fCIntroducing JSON\fP
.IP "\(bu" 2
\fCRFC7159: The JavaScript Object Notation (JSON) Data Interchange Format\fP
.IP "\(bu" 2
\fCStandard ECMA-404: The JSON Data Interchange Format\fP
.PP
.SS "v1\&.1 中的亮点 (2016-8-25)"
.IP "\(bu" 2
加入 \fBC:/Users/R2-D2/Desktop/STUDIA/Semestr\fP 5/Podstawy grafiki komputerowej/Projekt/Neon Jumper/src/rapidjson/doc/pointer\&.zh-cn\&.md 'JSON Pointer' 功能，可更简单地访问及更改 DOM。
.IP "\(bu" 2
加入 \fBC:/Users/R2-D2/Desktop/STUDIA/Semestr\fP 5/Podstawy grafiki komputerowej/Projekt/Neon Jumper/src/rapidjson/doc/schema\&.zh-cn\&.md 'JSON Schema' 功能，可在解析或生成 JSON 时进行校验。
.IP "\(bu" 2
加入 \fBC:/Users/R2-D2/Desktop/STUDIA/Semestr\fP 5/Podstawy grafiki komputerowej/Projekt/Neon Jumper/src/rapidjson/doc/dom\&.zh-cn\&.md '放宽的 JSON 语法' （注释、尾随逗号、NaN/Infinity）
.IP "\(bu" 2
使用 \fBC:/Users/R2-D2/Desktop/STUDIA/Semestr\fP 5/Podstawy grafiki komputerowej/Projekt/Neon Jumper/src/rapidjson/doc/tutorial\&.zh-cn\&.md 'C++11 范围 for 循环' 去遍历 array 和 object。
.IP "\(bu" 2
在 x86-64 架构下，缩减每个 \fCValue\fP 的内存开销从 24 字节至 16 字节。
.PP
.PP
其他改动请参考 \fBC:/Users/R2-D2/Desktop/STUDIA/Semestr\fP 5/Podstawy grafiki komputerowej/Projekt/Neon \fBJumper/src/rapidjson/CHANGELOG\&.md\fP 'change log'\&.
.SS "兼容性"
RapidJSON 是跨平台的。以下是一些曾测试的平台／编译器组合：
.IP "\(bu" 2
Visual C++ 2008/2010/2013 在 Windows (32/64-bit)
.IP "\(bu" 2
GNU C++ 3\&.8\&.x 在 Cygwin
.IP "\(bu" 2
Clang 3\&.4 在 Mac OS X (32/64-bit) 及 iOS
.IP "\(bu" 2
Clang 3\&.4 在 Android NDK
.PP
.PP
用户也可以在他们的平台上生成及执行单元测试。
.SS "安装"
RapidJSON 是只有头文件的 C++ 库。只需把 \fCinclude/rapidjson\fP 目录复制至系统或项目的 include 目录中。
.PP
RapidJSON 依赖于以下软件：
.IP "\(bu" 2
\fCCMake\fP 作为通用生成工具
.IP "\(bu" 2
(optional) \fCDoxygen\fP 用于生成文档
.IP "\(bu" 2
(optional) \fCgoogletest\fP 用于单元及性能测试
.PP
.PP
生成测试及例子的步骤：
.PP
.IP "1." 4
执行 \fCgit submodule update --init\fP 去获取 thirdparty submodules (google test)。
.IP "2." 4
在 rapidjson 目录下，建立一个 \fCbuild\fP 目录。
.IP "3." 4
在 \fCbuild\fP 目录下执行 \fCcmake \&.\&.\fP 命令以设置生成。Windows 用户可使用 cmake-gui 应用程序。
.IP "4." 4
在 Windows 下，编译生成在 build 目录中的 solution。在 Linux 下，于 build 目录运行 \fCmake\fP。
.PP
.PP
成功生成后，你会在 \fCbin\fP 的目录下找到编译后的测试及例子可执行文件。而生成的文档将位于 build 下的 \fCdoc/html\fP 目录。要执行测试，请在 build 下执行 \fCmake test\fP 或 \fCctest\fP。使用 \fCctest -V\fP 命令可获取详细的输出。
.PP
我们也可以把程序库安装至全系统中，只要在具管理权限下从 build 目录执行 \fCmake install\fP 命令。这样会按系统的偏好设置安装所有文件。当安装 RapidJSON 后，其他的 CMake 项目需要使用它时，可以通过在 \fCCMakeLists\&.txt\fP 加入一句 \fCfind_package(RapidJSON)\fP。
.SS "用法一览"
此简单例子解析一个 JSON 字符串至一个 document (DOM)，对 DOM 作出简单修改，最终把 DOM 转换（stringify）至 JSON 字符串。
.PP
.PP
.nf
// rapidjson/example/simpledom/simpledom\&.cpp`
#include "rapidjson/document\&.h"
#include "rapidjson/writer\&.h"
#include "rapidjson/stringbuffer\&.h"
#include <iostream>

using namespace rapidjson;

int main() {
    // 1\&. 把 JSON 解析至 DOM。
    const char* json = "{\"project\":\"rapidjson\",\"stars\":10}";
    Document d;
    d\&.Parse(json);

    // 2\&. 利用 DOM 作出修改。
    Value& s = d["stars"];
    s\&.SetInt(s\&.GetInt() + 1);

    // 3\&. 把 DOM 转换（stringify）成 JSON。
    StringBuffer buffer;
    Writer<StringBuffer> writer(buffer);
    d\&.Accept(writer);

    // Output {"project":"rapidjson","stars":11}
    std::cout << buffer\&.GetString() << std::endl;
    return 0;
}
.fi
.PP
.PP
注意此例子并没有处理潜在错误。
.PP
下图展示执行过程。
.PP
.PP
还有许多 \fC例子\fP 可供参考：
.PP
.IP "\(bu" 2
DOM API
.IP "  \(bu" 4
\fCtutorial\fP: DOM API 的基本使用方法。
.PP

.IP "\(bu" 2
SAX API
.IP "  \(bu" 4
\fCsimplereader\fP: 使用 \fCReader\fP 解析 JSON 时，打印所有 SAX 事件。
.IP "  \(bu" 4
\fCcondense\fP: 移除 JSON 中所有空白符的命令行工具。
.IP "  \(bu" 4
\fCpretty\fP: 为 JSON 加入缩进与换行的命令行工具，当中使用了 \fC\fBPrettyWriter\fP\fP。
.IP "  \(bu" 4
\fCcapitalize\fP: 把 JSON 中所有字符串改为大写的命令行工具。
.IP "  \(bu" 4
\fCmessagereader\fP: 使用 SAX API 去解析一个 JSON 报文。
.IP "  \(bu" 4
\fCserialize\fP: 使用 SAX API 去序列化 C++ 对象，生成 JSON。
.IP "  \(bu" 4
\fCjsonx\fP: 实现了一个 \fC\fBJsonxWriter\fP\fP，它能把 SAX 事件写成 \fCJSONx\fP（一种 XML）格式。这个例子是把 JSON 输入转换成 JSONx 格式的命令行工具。
.PP

.IP "\(bu" 2
\fBSchema\fP API
.IP "  \(bu" 4
\fCschemavalidator\fP: 使用 JSON \fBSchema\fP 去校验 JSON 的命令行工具。
.PP

.IP "\(bu" 2
进阶
.IP "  \(bu" 4
\fCprettyauto\fP: \fCpretty\fP 的修改版本，可自动处理任何 UTF 编码的 JSON。
.IP "  \(bu" 4
\fCparsebyparts\fP: 这例子中的 \fCAsyncDocumentParser\fP 类使用 C++ 线程来逐段解析 JSON。
.IP "  \(bu" 4
\fCfilterkey\fP: 移取使用者指定的键值的命令行工具。
.IP "  \(bu" 4
\fCfilterkeydom\fP: 如上的工具，但展示如何使用生成器（generator）去填充一个 \fCDocument\fP。 
.PP

.PP

