<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_annotated" xml:lang="en-US">
<title>Class List</title>
Here are the classes, structs, unions and interfaces with brief descriptions:<link linkend="_classrapidjson_1_1_allocator">Allocator</link>
<para>Concept for allocating, resizing and freeing memory block </para>
<link linkend="_class_animated">Animated</link><link linkend="_class_archiver">Archiver</link>
<para><link linkend="_class_archiver">Archiver</link> concept </para>
<link linkend="_struct_generic_value_1_1_array_data">GenericValue&lt; Encoding, Allocator &gt;::ArrayData</link><link linkend="_struct_a_s_c_i_i">ASCII&lt; CharType &gt;</link>
<para><link linkend="_struct_a_s_c_i_i">ASCII</link> encoding </para>
<link linkend="_class_assert_exception">AssertException</link><link linkend="_struct_auto_u_t_f">AutoUTF&lt; CharType &gt;</link>
<para>Dynamically select encoding according to stream&apos;s runtime-specified UTF encoding type </para>
<link linkend="_class_auto_u_t_f_input_stream">AutoUTFInputStream&lt; CharType, InputByteStream &gt;</link>
<para>Input stream wrapper with dynamically bound encoding and automatic encoding detection </para>
<link linkend="_class_auto_u_t_f_output_stream">AutoUTFOutputStream&lt; CharType, OutputByteStream &gt;</link>
<para>Output stream wrapper with dynamically bound encoding and automatic encoding detection </para>
<link linkend="_struct_base_reader_handler">BaseReaderHandler&lt; Encoding, Derived &gt;</link>
<para>Default implementation of Handler </para>
<link linkend="_class_basic_i_stream_wrapper">BasicIStreamWrapper&lt; StreamType &gt;</link>
<para>Wrapper of <computeroutput>std::basic_istream</computeroutput> into RapidJSON&apos;s Stream concept </para>
<link linkend="_class_basic_o_stream_wrapper">BasicOStreamWrapper&lt; StreamType &gt;</link>
<para>Wrapper of <computeroutput>std::basic_ostream</computeroutput> into RapidJSON&apos;s Stream concept </para>
<link linkend="_classinternal_1_1_big_integer">internal::BigInteger</link><link linkend="_class_box">Box</link><link linkend="_class_button">Button</link><link linkend="_class_canvas">Canvas</link><link linkend="_struct_capitalize_filter">CapitalizeFilter&lt; OutputHandler &gt;</link><link linkend="_class_circle">Circle</link><link linkend="_class_crt_allocator">CrtAllocator</link>
<para>C-runtime library allocator </para>
<link linkend="_class_cursor_stream_wrapper">CursorStreamWrapper&lt; InputStream, Encoding &gt;</link>
<para>Cursor stream wrapper for counting line and column number if error exists </para>
<link linkend="_class_custom_string_stream">CustomStringStream&lt; Encoding &gt;</link><link linkend="_class_damageable">Damageable</link><link linkend="_union_generic_value_1_1_data">GenericValue&lt; Encoding, Allocator &gt;::Data</link><link linkend="_classinternal_1_1_decoded_stream">internal::DecodedStream&lt; SourceStream, Encoding &gt;</link><link linkend="_class_dependent">Dependent</link><link linkend="_structinternal_1_1_diy_fp">internal::DiyFp</link><link linkend="_classinternal_1_1_double">internal::Double</link><link linkend="_class_education">Education</link><link linkend="_class_employee">Employee</link><link linkend="_class_encoded_input_stream">EncodedInputStream&lt; Encoding, InputByteStream &gt;</link>
<para>Input byte stream wrapper with a statically bound encoding </para>
<link linkend="_class_encoded_input_stream_3_01_u_t_f8_3_4_00_01_memory_stream_01_4">EncodedInputStream&lt; UTF8&lt;&gt;, MemoryStream &gt;</link>
<para>Specialized for <link linkend="_struct_u_t_f8">UTF8</link> <link linkend="_struct_memory_stream">MemoryStream</link> </para>
<link linkend="_class_encoded_output_stream">EncodedOutputStream&lt; Encoding, OutputByteStream &gt;</link>
<para>Output byte stream wrapper with statically bound encoding </para>
<link linkend="_class_encoded_stream_test">EncodedStreamTest</link><link linkend="_classrapidjson_1_1_encoding">Encoding</link>
<para>Concept for encoding of Unicode characters </para>
<link linkend="_class_enemy">Enemy</link><link linkend="_class_file_read_stream">FileReadStream</link>
<para>File byte stream for input using fread() </para>
<link linkend="_class_file_stream_test">FileStreamTest</link><link linkend="_class_file_write_stream">FileWriteStream</link>
<para>Wrapper of C file stream for output using fwrite() </para>
<link linkend="_class_filter_key_handler">FilterKeyHandler&lt; OutputHandler &gt;</link><link linkend="_class_filter_key_reader">FilterKeyReader&lt; InputStream &gt;</link><link linkend="_struct_generic_value_1_1_flag">GenericValue&lt; Encoding, Allocator &gt;::Flag</link><link linkend="_struct_foo">Foo</link><link linkend="_class_game_state">GameState</link><link linkend="_class_generic_array">GenericArray&lt; Const, ValueT &gt;</link>
<para>Helper class for accessing Value of array type </para>
<link linkend="_class_generic_document">GenericDocument&lt; Encoding, Allocator, StackAllocator &gt;</link>
<para>A document for parsing JSON text as DOM </para>
<link linkend="_struct_generic_insitu_string_stream">GenericInsituStringStream&lt; Encoding &gt;</link>
<para>A read-write string stream </para>
<link linkend="_class_generic_member">GenericMember&lt; Encoding, Allocator &gt;</link>
<para>Name-value pair in a JSON object value </para>
<link linkend="_class_generic_member_iterator">GenericMemberIterator&lt; Const, Encoding, Allocator &gt;</link>
<para>(Constant) member iterator for a JSON object value </para>
<link linkend="_struct_generic_memory_buffer">GenericMemoryBuffer&lt; Allocator &gt;</link>
<para>Represents an in-memory output byte stream </para>
<link linkend="_class_generic_object">GenericObject&lt; Const, ValueT &gt;</link>
<para>Helper class for accessing Value of object type </para>
<link linkend="_class_generic_pointer">GenericPointer&lt; ValueType, Allocator &gt;</link>
<para>Represents a JSON Pointer. Use Pointer for <link linkend="_struct_u_t_f8">UTF8</link> encoding and default allocator </para>
<link linkend="_class_generic_reader">GenericReader&lt; SourceEncoding, TargetEncoding, StackAllocator &gt;</link>
<para>SAX-style JSON parser. Use <link linkend="_md_src_rapidjson_doc_sax_zh_cn_1Reader">Reader</link> for <link linkend="_struct_u_t_f8">UTF8</link> encoding and default allocator </para>
<link linkend="_classinternal_1_1_generic_regex">internal::GenericRegex&lt; Encoding, Allocator &gt;</link>
<para>Regular expression engine with subset of ECMAscript grammar </para>
<link linkend="_classinternal_1_1_generic_regex_search">internal::GenericRegexSearch&lt; RegexType, Allocator &gt;</link><link linkend="_class_generic_schema_document">GenericSchemaDocument&lt; ValueT, Allocator &gt;</link>
<para>JSON schema document </para>
<link linkend="_class_generic_schema_validator">GenericSchemaValidator&lt; SchemaDocumentType, OutputHandler, StateAllocator &gt;</link>
<para>JSON <link linkend="_class_schema">Schema</link> Validator </para>
<link linkend="_class_generic_stream_wrapper">GenericStreamWrapper&lt; InputStream, Encoding &gt;</link>
<para>A Stream Wrapper </para>
<link linkend="_class_generic_string_buffer">GenericStringBuffer&lt; Encoding, Allocator &gt;</link>
<para>Represents an in-memory output stream </para>
<link linkend="_struct_generic_string_ref">GenericStringRef&lt; CharType &gt;</link>
<para>Reference to a constant string (not taking a copy) </para>
<link linkend="_struct_generic_string_stream">GenericStringStream&lt; Encoding &gt;</link>
<para>Read-only string stream </para>
<link linkend="_class_generic_uri">GenericUri&lt; ValueType, Allocator &gt;</link><link linkend="_class_generic_value">GenericValue&lt; Encoding, Allocator &gt;</link>
<para>Represents a JSON value. Use Value for <link linkend="_struct_u_t_f8">UTF8</link> encoding and default allocator </para>
<link linkend="_struct_group">Group</link><link linkend="_classrapidjson_1_1_handler">Handler</link>
<para>Concept for receiving events from <link linkend="_class_generic_reader">GenericReader</link> upon parsing. The functions return true if no error occurs. If they return false, the event publisher should terminate the process </para>
<link linkend="_struct_handler_terminate_at_end_array">HandlerTerminateAtEndArray</link><link linkend="_struct_handler_terminate_at_end_object">HandlerTerminateAtEndObject</link><link linkend="_struct_handler_terminate_at_start_array">HandlerTerminateAtStartArray</link><link linkend="_struct_handler_terminate_at_start_object">HandlerTerminateAtStartObject</link><link linkend="_classinternal_1_1_hasher">internal::Hasher&lt; Encoding, Allocator &gt;</link><link linkend="_struct_generic_value_1_1_number_1_1_i">GenericValue&lt; Encoding, Allocator &gt;::Number::I</link><link linkend="_class_i_generic_remote_schema_document_provider">IGenericRemoteSchemaDocumentProvider&lt; SchemaDocumentType &gt;</link><link linkend="_structimaxdiv__t">imaxdiv_t</link><link linkend="_classinternal_1_1_i_schema_state_factory">internal::ISchemaStateFactory&lt; SchemaType &gt;</link><link linkend="_classinternal_1_1_i_schema_validator">internal::ISchemaValidator</link><link linkend="_structinternal_1_1_is_generic_value">internal::IsGenericValue&lt; T &gt;</link><link linkend="_structinternal_1_1_is_generic_value_impl">internal::IsGenericValueImpl&lt; T, Encoding, Allocator &gt;</link><link linkend="_structinternal_1_1_is_generic_value_impl_3_01_t_00_01typename_01_void_3_01typename_01_t_1_1_enco3a51e9d8b4986f001b39e1e8edecb66a">internal::IsGenericValueImpl&lt; T, typename Void&lt; typename T::EncodingType &gt;::Type, typename Void&lt; typename T::AllocatorType &gt;::Type &gt;</link><link linkend="_structinternal_1_1_is_ref_counted">internal::IsRefCounted&lt; typename, typename &gt;</link><link linkend="_structinternal_1_1_is_ref_counted_3_01_t_00_01typename_01internal_1_1_enable_if_cond_3_01_t_1_1k_ref_counted_01_4_1_1_type_01_4">internal::IsRefCounted&lt; T, typename internal::EnableIfCond&lt; T::kRefCounted &gt;::Type &gt;</link><link linkend="_class_i_stream_wrapper">IStreamWrapper</link><link linkend="_struct_iterative_parsing_reader_handler">IterativeParsingReaderHandler&lt; Encoding &gt;</link><link linkend="_classinternal_1_1_i_validation_error_handler">internal::IValidationErrorHandler&lt; SchemaType &gt;</link><link linkend="_class_json_reader">JsonReader</link>
<para>Represents a JSON reader which implements <link linkend="_class_archiver">Archiver</link> concept </para>
<link linkend="_struct_json_reader_stack_item">JsonReaderStackItem</link><link linkend="_class_json_writer">JsonWriter</link><link linkend="_class_jsonx_writer">JsonxWriter&lt; OutputStream &gt;</link><link linkend="_class_ka_xC5_xBCdy">Ka≈ºdy</link><link linkend="_class_klasa">Klasa</link><link linkend="_class_layer">Layer</link><link linkend="_class_layer_object">LayerObject</link><link linkend="_struct_writer_1_1_level">Writer&lt; OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags &gt;::Level</link>
<para>Information for each nested level </para>
<link linkend="_class_level_one_state">LevelOneState</link><link linkend="_class_level_two_state">LevelTwoState</link><link linkend="_class_load_map">LoadMap</link><link linkend="_class_lookahead_parser">LookaheadParser</link><link linkend="_class_lookahead_parser_handler">LookaheadParserHandler</link><link linkend="_class_main_menu_state">MainMenuState</link><link linkend="_class_map">Map</link><link linkend="_class_memory_pool_allocator">MemoryPoolAllocator&lt; BaseAllocator &gt;</link>
<para>Default memory allocator used by the parser and DOM </para>
<link linkend="_struct_memory_stream">MemoryStream</link>
<para>Represents an in-memory input byte stream </para>
<link linkend="_struct_message_handler">MessageHandler</link><link linkend="_classmyjson_1_1_my_allocator">myjson::MyAllocator</link><link linkend="_struct_my_handler">MyHandler</link><link linkend="_struct_name_comparator">NameComparator</link><link linkend="_struct_no_op_handler">NoOpHandler</link><link linkend="_struct_null_stream">NullStream</link><link linkend="_union_generic_value_1_1_number">GenericValue&lt; Encoding, Allocator &gt;::Number</link><link linkend="_struct_numbers_as_strings_handler">NumbersAsStringsHandler</link><link linkend="_struct_numbers_as_strings_handler_w_char__t">NumbersAsStringsHandlerWChar_t</link><link linkend="_struct_generic_value_1_1_object_data">GenericValue&lt; Encoding, Allocator &gt;::ObjectData</link><link linkend="_class_opisuje">Opisuje</link><link linkend="_class_o_stream_wrapper">OStreamWrapper</link><link linkend="_struct_output_string_stream">OutputStringStream</link><link linkend="_struct_parse_array_handler">ParseArrayHandler&lt; count &gt;</link><link linkend="_struct_parse_bool_handler">ParseBoolHandler&lt; expect &gt;</link><link linkend="_struct_parse_double_handler">ParseDoubleHandler</link><link linkend="_struct_parse_empty_object_handler">ParseEmptyObjectHandler</link><link linkend="_struct_parse_int64_handler">ParseInt64Handler</link><link linkend="_struct_parse_int_handler">ParseIntHandler</link><link linkend="_struct_parse_multiple_root_handler">ParseMultipleRootHandler</link><link linkend="_struct_parse_object_handler">ParseObjectHandler</link><link linkend="_struct_parse_result">ParseResult</link>
<para>Result of parsing (wraps ParseErrorCode) </para>
<link linkend="_struct_parse_string_handler">ParseStringHandler&lt; Encoding &gt;</link><link linkend="_struct_parse_uint64_handler">ParseUint64Handler</link><link linkend="_struct_parse_uint_handler">ParseUintHandler</link><link linkend="_class_generic_pointer_1_1_percent_encode_stream">GenericPointer&lt; ValueType, Allocator &gt;::PercentEncodeStream&lt; OutputStream &gt;</link>
<para>A helper stream to encode character (UTF-8 code unit) into percent-encoded sequence </para>
<link linkend="_class_person">Person</link><link linkend="_class_player">Player</link><link linkend="_class_player_h_u_d">PlayerHUD</link><link linkend="_class_pretty_writer">PrettyWriter&lt; OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags &gt;</link>
<para><link linkend="_class_writer">Writer</link> with indentation and spacing </para>
<link linkend="_class_przedstawia">Przedstawia</link><link linkend="_class_random">Random</link><link linkend="_class_rapid_json">RapidJson</link><link linkend="_struct_std_allocator_1_1rebind">StdAllocator&lt; T, BaseAllocator &gt;::rebind&lt; U &gt;</link><link linkend="_struct_std_allocator_3_01void_00_01_base_allocator_01_4_1_1rebind">StdAllocator&lt; void, BaseAllocator &gt;::rebind&lt; U &gt;</link><link linkend="_class_remote_schema_document_provider">RemoteSchemaDocumentProvider&lt; SchemaDocumentType &gt;</link><link linkend="_class_reprezentuje">Reprezentuje</link><link linkend="_struct_scan_copy_unescaped_string_handler">ScanCopyUnescapedStringHandler</link><link linkend="_classinternal_1_1_schema">internal::Schema&lt; SchemaDocumentType &gt;</link><link linkend="_class_schema">Schema</link><link linkend="_class_schema_validating_reader">SchemaValidatingReader&lt; parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator &gt;</link>
<para>A helper class for parsing with validation </para>
<link linkend="_structinternal_1_1_schema_validation_context">internal::SchemaValidationContext&lt; SchemaDocumentType &gt;</link><link linkend="_class_shape">Shape</link><link linkend="_struct_generic_value_1_1_short_string">GenericValue&lt; Encoding, Allocator &gt;::ShortString</link><link linkend="_class_slime">Slime</link><link linkend="_classinternal_1_1_stack">internal::Stack&lt; Allocator &gt;</link>
<para>A type-unsafe stack for storing different types of data </para>
<link linkend="_class_stan">Stan</link><link linkend="_class_std_allocator">StdAllocator&lt; T, BaseAllocator &gt;</link><link linkend="_class_std_allocator_3_01void_00_01_base_allocator_01_4">StdAllocator&lt; void, BaseAllocator &gt;</link><link linkend="_classrapidjson_1_1_stream">Stream</link>
<para>Concept for reading and writing characters </para>
<link linkend="_classinternal_1_1_stream_local_copy">internal::StreamLocalCopy&lt; Stream, int &gt;</link><link linkend="_classinternal_1_1_stream_local_copy_3_01_stream_00_010_01_4">internal::StreamLocalCopy&lt; Stream, 0 &gt;</link>
<para>Keep reference </para>
<link linkend="_classinternal_1_1_stream_local_copy_3_01_stream_00_011_01_4">internal::StreamLocalCopy&lt; Stream, 1 &gt;</link>
<para>Do copy optimization </para>
<link linkend="_struct_stream_traits">StreamTraits&lt; Stream &gt;</link>
<para>Provides additional information for stream </para>
<link linkend="_struct_stream_traits_3_01_generic_insitu_string_stream_3_01_encoding_01_4_01_4">StreamTraits&lt; GenericInsituStringStream&lt; Encoding &gt; &gt;</link><link linkend="_struct_stream_traits_3_01_generic_string_stream_3_01_encoding_01_4_01_4">StreamTraits&lt; GenericStringStream&lt; Encoding &gt; &gt;</link><link linkend="_struct_generic_value_1_1_string">GenericValue&lt; Encoding, Allocator &gt;::String</link><link linkend="_struct_student">Student</link><link linkend="_struct_terminate_handler">TerminateHandler&lt; e &gt;</link><link linkend="_struct_test_std_allocator_data">TestStdAllocatorData</link><link linkend="_struct_schema_1_1_test_suite">Schema::TestSuite</link><link linkend="_class_tile_map">TileMap</link><link linkend="_class_tile_set">TileSet</link><link linkend="_class_tile_set_map">TileSetMap</link><link linkend="_struct_generic_pointer_1_1_token">GenericPointer&lt; ValueType, Allocator &gt;::Token</link>
<para>A token is the basic units of internal representation </para>
<link linkend="_structinternal_1_1_token_helper">internal::TokenHelper&lt; Stack, Ch &gt;</link><link linkend="_structinternal_1_1_token_helper_3_01_stack_00_01char_01_4">internal::TokenHelper&lt; Stack, char &gt;</link><link linkend="_struct_traits">Traits&lt; T &gt;</link><link linkend="_struct_traits_3_01int32__t_01_4">Traits&lt; int32_t &gt;</link><link linkend="_struct_traits_3_01int64__t_01_4">Traits&lt; int64_t &gt;</link><link linkend="_struct_traits_3_01uint32__t_01_4">Traits&lt; uint32_t &gt;</link><link linkend="_struct_traits_3_01uint64__t_01_4">Traits&lt; uint64_t &gt;</link><link linkend="_struct_transcoder">Transcoder&lt; SourceEncoding, TargetEncoding &gt;</link>
<para>Encoding conversion </para>
<link linkend="_struct_transcoder_3_01_encoding_00_01_encoding_01_4">Transcoder&lt; Encoding, Encoding &gt;</link>
<para>Specialization of <link linkend="_struct_transcoder">Transcoder</link> with same source and target encoding </para>
<link linkend="_structinternal_1_1_type_helper">internal::TypeHelper&lt; ValueType, T &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01bool_01_4">internal::TypeHelper&lt; ValueType, bool &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01const_01typename_01_value_type_1_1_ch_01_5_01_4">internal::TypeHelper&lt; ValueType, const typename ValueType::Ch * &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01double_01_4">internal::TypeHelper&lt; ValueType, double &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01float_01_4">internal::TypeHelper&lt; ValueType, float &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01int_01_4">internal::TypeHelper&lt; ValueType, int &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01int64__t_01_4">internal::TypeHelper&lt; ValueType, int64_t &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01typename_01_value_type_1_1_array_01_4">internal::TypeHelper&lt; ValueType, typename ValueType::Array &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01typename_01_value_type_1_1_const_array_01_4">internal::TypeHelper&lt; ValueType, typename ValueType::ConstArray &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01typename_01_value_type_1_1_const_object_01_4">internal::TypeHelper&lt; ValueType, typename ValueType::ConstObject &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01typename_01_value_type_1_1_object_01_4">internal::TypeHelper&lt; ValueType, typename ValueType::Object &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01uint64__t_01_4">internal::TypeHelper&lt; ValueType, uint64_t &gt;</link><link linkend="_structinternal_1_1_type_helper_3_01_value_type_00_01unsigned_01_4">internal::TypeHelper&lt; ValueType, unsigned &gt;</link><link linkend="_struct_generic_value_1_1_number_1_1_u">GenericValue&lt; Encoding, Allocator &gt;::Number::U</link><link linkend="_unioninternal_1_1_hasher_1_1_number_1_1_u">internal::Hasher&lt; Encoding, Allocator &gt;::Number::U</link><link linkend="_struct_u_t_f16">UTF16&lt; CharType &gt;</link>
<para>UTF-16 encoding </para>
<link linkend="_struct_u_t_f16_b_e">UTF16BE&lt; CharType &gt;</link>
<para>UTF-16 big endian encoding </para>
<link linkend="_struct_u_t_f16_l_e">UTF16LE&lt; CharType &gt;</link>
<para>UTF-16 little endian encoding </para>
<link linkend="_struct_u_t_f32">UTF32&lt; CharType &gt;</link>
<para>UTF-32 encoding </para>
<link linkend="_struct_u_t_f32_b_e">UTF32BE&lt; CharType &gt;</link>
<para>UTF-32 big endian encoding </para>
<link linkend="_struct_u_t_f32_l_e">UTF32LE&lt; CharType &gt;</link>
<para>UTF-32 little endian enocoding </para>
<link linkend="_struct_u_t_f8">UTF8&lt; CharType &gt;</link>
<para>UTF-8 encoding </para>
<link linkend="_struct_value_counter">ValueCounter</link><link linkend="_struct_value_int_comparer">ValueIntComparer</link><link linkend="_class_w_i_stream_wrapper">WIStreamWrapper</link><link linkend="_class_writer">Writer&lt; OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags &gt;</link>
<para>JSON writer </para>
</section>
