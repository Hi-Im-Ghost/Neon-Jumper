<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_md_src_rapidjson_doc_sax" xml:lang="en-US">

<para>The term &quot;SAX&quot; originated from <link xlink:href="http://en.wikipedia.org/wiki/Simple_API_for_XML">Simple API for XML</link>. We borrowed this term for JSON parsing and generation.</para>

<para>In RapidJSON, <computeroutput>Reader</computeroutput> (typedef of <computeroutput><link linkend="_class_generic_reader">GenericReader</link>&lt;...&gt;</computeroutput>) is the SAX-style parser for JSON, and <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> (typedef of <computeroutput>GenericWriter&lt;...&gt;</computeroutput>) is the SAX-style generator for JSON.</para>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1Reader">
<title>Reader</title>

<para><computeroutput>Reader</computeroutput> parses a JSON from a stream. While it reads characters from the stream, it analyzes the characters according to the syntax of JSON, and publishes events to a handler.</para>

<para>For example, here is a JSON.</para>

<para><literallayout><computeroutput>{
&#32;&#32;&#32;&#32;&quot;hello&quot;:&#32;&quot;world&quot;,
&#32;&#32;&#32;&#32;&quot;t&quot;:&#32;true&#32;,
&#32;&#32;&#32;&#32;&quot;f&quot;:&#32;false,
&#32;&#32;&#32;&#32;&quot;n&quot;:&#32;null,
&#32;&#32;&#32;&#32;&quot;i&quot;:&#32;123,
&#32;&#32;&#32;&#32;&quot;pi&quot;:&#32;3.1416,
&#32;&#32;&#32;&#32;&quot;a&quot;:&#32;[1,&#32;2,&#32;3,&#32;4]
}
</computeroutput></literallayout></para>

<para>When a <computeroutput>Reader</computeroutput> parses this JSON, it publishes the following events to the handler sequentially:</para>

<para><literallayout><computeroutput>StartObject()
Key(&quot;hello&quot;,&#32;5,&#32;true)
String(&quot;world&quot;,&#32;5,&#32;true)
Key(&quot;t&quot;,&#32;1,&#32;true)
Bool(true)
Key(&quot;f&quot;,&#32;1,&#32;true)
Bool(false)
Key(&quot;n&quot;,&#32;1,&#32;true)
Null()
Key(&quot;i&quot;)
Uint(123)
Key(&quot;pi&quot;)
Double(3.1416)
Key(&quot;a&quot;)
StartArray()
Uint(1)
Uint(2)
Uint(3)
Uint(4)
EndArray(4)
EndObject(7)
</computeroutput></literallayout></para>

<para>These events can be easily matched with the JSON, but some event parameters need further explanation. Let&apos;s see the <computeroutput>simplereader</computeroutput> example which produces exactly the same output as above:</para>

<para><literallayout><computeroutput>#include&#32;&quot;rapidjson/reader.h&quot;
#include&#32;&lt;iostream&gt;

using&#32;namespace&#32;rapidjson;
using&#32;namespace&#32;std;

struct&#32;MyHandler&#32;:&#32;public&#32;BaseReaderHandler&lt;UTF8&lt;&gt;,&#32;MyHandler&gt;&#32;{
&#32;&#32;&#32;&#32;bool&#32;Null()&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Null()&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Bool(bool&#32;b)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Bool(&quot;&#32;&lt;&lt;&#32;boolalpha&#32;&lt;&lt;&#32;b&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Int(int&#32;i)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Int(&quot;&#32;&lt;&lt;&#32;i&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Uint(unsigned&#32;u)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Uint(&quot;&#32;&lt;&lt;&#32;u&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Int64(int64_t&#32;i)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Int64(&quot;&#32;&lt;&lt;&#32;i&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Uint64(uint64_t&#32;u)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Uint64(&quot;&#32;&lt;&lt;&#32;u&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Double(double&#32;d)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;Double(&quot;&#32;&lt;&lt;&#32;d&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;String(const&#32;char*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy)&#32;{&#32;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;&quot;String(&quot;&#32;&lt;&lt;&#32;str&#32;&lt;&lt;&#32;&quot;,&#32;&quot;&#32;&lt;&lt;&#32;length&#32;&lt;&lt;&#32;&quot;,&#32;&quot;&#32;&lt;&lt;&#32;boolalpha&#32;&lt;&lt;&#32;copy&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;true;
&#32;&#32;&#32;&#32;}
&#32;&#32;&#32;&#32;bool&#32;StartObject()&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;StartObject()&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;Key(const&#32;char*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy)&#32;{&#32;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;&quot;Key(&quot;&#32;&lt;&lt;&#32;str&#32;&lt;&lt;&#32;&quot;,&#32;&quot;&#32;&lt;&lt;&#32;length&#32;&lt;&lt;&#32;&quot;,&#32;&quot;&#32;&lt;&lt;&#32;boolalpha&#32;&lt;&lt;&#32;copy&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;true;
&#32;&#32;&#32;&#32;}
&#32;&#32;&#32;&#32;bool&#32;EndObject(SizeType&#32;memberCount)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;EndObject(&quot;&#32;&lt;&lt;&#32;memberCount&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;StartArray()&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;StartArray()&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
&#32;&#32;&#32;&#32;bool&#32;EndArray(SizeType&#32;elementCount)&#32;{&#32;cout&#32;&lt;&lt;&#32;&quot;EndArray(&quot;&#32;&lt;&lt;&#32;elementCount&#32;&lt;&lt;&#32;&quot;)&quot;&#32;&lt;&lt;&#32;endl;&#32;return&#32;true;&#32;}
};

void&#32;main()&#32;{
&#32;&#32;&#32;&#32;const&#32;char&#32;json[]&#32;=&#32;&quot;&#32;{&#32;\&quot;hello\&quot;&#32;:&#32;\&quot;world\&quot;,&#32;\&quot;t\&quot;&#32;:&#32;true&#32;,&#32;\&quot;f\&quot;&#32;:&#32;false,&#32;\&quot;n\&quot;:&#32;null,&#32;\&quot;i\&quot;:123,&#32;\&quot;pi\&quot;:&#32;3.1416,&#32;\&quot;a\&quot;:[1,&#32;2,&#32;3,&#32;4]&#32;}&#32;&quot;;

&#32;&#32;&#32;&#32;MyHandler&#32;handler;
&#32;&#32;&#32;&#32;Reader&#32;reader;
&#32;&#32;&#32;&#32;StringStream&#32;ss(json);
&#32;&#32;&#32;&#32;reader.Parse(ss,&#32;handler);
}
</computeroutput></literallayout></para>

<para>Note that RapidJSON uses templates to statically bind the <computeroutput>Reader</computeroutput> type and the handler type, instead of using classes with virtual functions. This paradigm can improve performance by inlining functions.</para>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1Handler">
<title>Handler</title>

<para>As shown in the previous example, the user needs to implement a handler which consumes the events (via function calls) from the <computeroutput>Reader</computeroutput>. The handler must contain the following member functions.</para>

<para><literallayout><computeroutput>class&#32;Handler&#32;{
&#32;&#32;&#32;&#32;bool&#32;Null();
&#32;&#32;&#32;&#32;bool&#32;Bool(bool&#32;b);
&#32;&#32;&#32;&#32;bool&#32;Int(int&#32;i);
&#32;&#32;&#32;&#32;bool&#32;Uint(unsigned&#32;i);
&#32;&#32;&#32;&#32;bool&#32;Int64(int64_t&#32;i);
&#32;&#32;&#32;&#32;bool&#32;Uint64(uint64_t&#32;i);
&#32;&#32;&#32;&#32;bool&#32;Double(double&#32;d);
&#32;&#32;&#32;&#32;bool&#32;RawNumber(const&#32;Ch*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy);
&#32;&#32;&#32;&#32;bool&#32;String(const&#32;Ch*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy);
&#32;&#32;&#32;&#32;bool&#32;StartObject();
&#32;&#32;&#32;&#32;bool&#32;Key(const&#32;Ch*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy);
&#32;&#32;&#32;&#32;bool&#32;EndObject(SizeType&#32;memberCount);
&#32;&#32;&#32;&#32;bool&#32;StartArray();
&#32;&#32;&#32;&#32;bool&#32;EndArray(SizeType&#32;elementCount);
};
</computeroutput></literallayout></para>

<para><computeroutput>Null()</computeroutput> is called when the <computeroutput>Reader</computeroutput> encounters a JSON null value.</para>

<para><computeroutput>Bool(bool)</computeroutput> is called when the <computeroutput>Reader</computeroutput> encounters a JSON true or false value.</para>

<para>When the <computeroutput>Reader</computeroutput> encounters a JSON number, it chooses a suitable C++ type mapping. And then it calls <emphasis>one</emphasis> function out of <computeroutput>Int(int)</computeroutput>, <computeroutput>Uint(unsigned)</computeroutput>, <computeroutput>Int64(int64_t)</computeroutput>, <computeroutput>Uint64(uint64_t)</computeroutput> and <computeroutput>Double(double)</computeroutput>. If <computeroutput>kParseNumbersAsStrings</computeroutput> is enabled, <computeroutput>Reader</computeroutput> will always calls <computeroutput>RawNumber()</computeroutput> instead.</para>

<para><computeroutput>String(const char* str, SizeType length, bool copy)</computeroutput> is called when the <computeroutput>Reader</computeroutput> encounters a string. The first parameter is pointer to the string. The second parameter is the length of the string (excluding the null terminator). Note that RapidJSON supports null character <computeroutput>\0</computeroutput> inside a string. If such situation happens, <computeroutput>strlen(str) &lt; length</computeroutput>. The last <computeroutput>copy</computeroutput> indicates whether the handler needs to make a copy of the string. For normal parsing, <computeroutput>copy = true</computeroutput>. Only when <emphasis>insitu</emphasis> parsing is used, <computeroutput>copy = false</computeroutput>. And be aware that the character type depends on the target encoding, which will be explained later.</para>

<para>When the <computeroutput>Reader</computeroutput> encounters the beginning of an object, it calls <computeroutput>StartObject()</computeroutput>. An object in JSON is a set of name-value pairs. If the object contains members it first calls <computeroutput>Key()</computeroutput> for the name of member, and then calls functions depending on the type of the value. These calls of name-value pairs repeat until calling <computeroutput>EndObject(SizeType memberCount)</computeroutput>. Note that the <computeroutput>memberCount</computeroutput> parameter is just an aid for the handler; users who do not need this parameter may ignore it.</para>

<para>Arrays are similar to objects, but simpler. At the beginning of an array, the <computeroutput>Reader</computeroutput> calls <computeroutput>BeginArray()</computeroutput>. If there is elements, it calls functions according to the types of element. Similarly, in the last call <computeroutput>EndArray(SizeType elementCount)</computeroutput>, the parameter <computeroutput>elementCount</computeroutput> is just an aid for the handler.</para>

<para>Every handler function returns a <computeroutput>bool</computeroutput>. Normally it should return <computeroutput>true</computeroutput>. If the handler encounters an error, it can return <computeroutput>false</computeroutput> to notify the event publisher to stop further processing.</para>

<para>For example, when we parse a JSON with <computeroutput>Reader</computeroutput> and the handler detects that the JSON does not conform to the required schema, the handler can return <computeroutput>false</computeroutput> and let the <computeroutput>Reader</computeroutput> stop further parsing. This will place the <computeroutput>Reader</computeroutput> in an error state, with error code <computeroutput>kParseErrorTermination</computeroutput>.</para>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1GenericReader">
<title>GenericReader</title>

<para>As mentioned before, <computeroutput>Reader</computeroutput> is a typedef of a template class <computeroutput><link linkend="_class_generic_reader">GenericReader</link></computeroutput>:</para>

<para><literallayout><computeroutput>namespace&#32;rapidjson&#32;{

template&#32;&lt;typename&#32;SourceEncoding,&#32;typename&#32;TargetEncoding,&#32;typename&#32;Allocator&#32;=&#32;MemoryPoolAllocator&lt;&gt;&#32;&gt;
class&#32;GenericReader&#32;{
&#32;&#32;&#32;&#32;//&#32;...
};

typedef&#32;GenericReader&lt;UTF8&lt;&gt;,&#32;UTF8&lt;&gt;&#32;&gt;&#32;Reader;

}&#32;//&#32;namespace&#32;rapidjson
</computeroutput></literallayout></para>

<para>The <computeroutput>Reader</computeroutput> uses UTF-8 as both source and target encoding. The source encoding means the encoding in the JSON stream. The target encoding means the encoding of the <computeroutput>str</computeroutput> parameter in <computeroutput>String()</computeroutput> calls. For example, to parse a UTF-8 stream and output UTF-16 string events, you can define a reader by:</para>

<para><literallayout><computeroutput>GenericReader&lt;UTF8&lt;&gt;,&#32;UTF16&lt;&gt;&#32;&gt;&#32;reader;
</computeroutput></literallayout></para>

<para>Note that, the default character type of <computeroutput><link linkend="_struct_u_t_f16">UTF16</link></computeroutput> is <computeroutput>wchar_t</computeroutput>. So this <computeroutput>reader</computeroutput> needs to call <computeroutput>String(const wchar_t*, SizeType, bool)</computeroutput> of the handler.</para>

<para>The third template parameter <computeroutput>Allocator</computeroutput> is the allocator type for internal data structure (actually a stack).</para>
</section>
<section xml:id="_md_src_rapidjson_doc_schema_zh_cn_1SaxParsing">
<title>Parsing</title>

<para>The main function of <computeroutput>Reader</computeroutput> is used to parse JSON.</para>

<para><literallayout><computeroutput>template&#32;&lt;unsigned&#32;parseFlags,&#32;typename&#32;InputStream,&#32;typename&#32;Handler&gt;
bool&#32;Parse(InputStream&amp;&#32;is,&#32;Handler&amp;&#32;handler);

//&#32;with&#32;parseFlags&#32;=&#32;kDefaultParseFlags
template&#32;&lt;typename&#32;InputStream,&#32;typename&#32;Handler&gt;
bool&#32;Parse(InputStream&amp;&#32;is,&#32;Handler&amp;&#32;handler);
</computeroutput></literallayout></para>

<para>If an error occurs during parsing, it will return <computeroutput>false</computeroutput>. User can also call <computeroutput>bool HasParseError()</computeroutput>, <computeroutput>ParseErrorCode GetParseErrorCode()</computeroutput> and <computeroutput>size_t GetErrorOffset()</computeroutput> to obtain the error states. In fact, <computeroutput>Document</computeroutput> uses these <computeroutput>Reader</computeroutput> functions to obtain parse errors. Please refer to <link linkend="_dom_8md">DOM</link> for details about parse errors.</para>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_1TokenByTokenParsing">
<title>Token-by-Token Parsing</title>

<para>Some users may wish to parse a JSON input stream a single token at a time, instead of immediately parsing an entire document without stopping. To parse JSON this way, instead of calling <computeroutput>Parse</computeroutput>, you can use the <computeroutput>IterativeParse</computeroutput> set of functions:</para>

<para><literallayout><computeroutput>void&#32;IterativeParseInit();

template&#32;&lt;unsigned&#32;parseFlags,&#32;typename&#32;InputStream,&#32;typename&#32;Handler&gt;
bool&#32;IterativeParseNext(InputStream&amp;&#32;is,&#32;Handler&amp;&#32;handler);

bool&#32;IterativeParseComplete();
</computeroutput></literallayout></para>

<para>Here is an example of iteratively parsing JSON, token by token:</para>

<para><literallayout><computeroutput>reader.IterativeParseInit();
while&#32;(!reader.IterativeParseComplete())&#32;{
&#32;&#32;&#32;&#32;reader.IterativeParseNext&lt;kParseDefaultFlags&gt;(is,&#32;handler);
&#32;&#32;&#32;&#32;//&#32;Your&#32;handler&#32;has&#32;been&#32;called&#32;once.
}
</computeroutput></literallayout></para>
</section>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1Writer">
<title>Writer</title>

<para><computeroutput>Reader</computeroutput> converts (parses) JSON into events. <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> does exactly the opposite. It converts events into JSON.</para>

<para><computeroutput><link linkend="_class_writer">Writer</link></computeroutput> is very easy to use. If your application only need to converts some data into JSON, it may be a good choice to use <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> directly, instead of building a <computeroutput>Document</computeroutput> and then stringifying it with a <computeroutput><link linkend="_class_writer">Writer</link></computeroutput>.</para>

<para>In <computeroutput>simplewriter</computeroutput> example, we do exactly the reverse of <computeroutput>simplereader</computeroutput>.</para>

<para><literallayout><computeroutput>#include&#32;&quot;rapidjson/writer.h&quot;
#include&#32;&quot;rapidjson/stringbuffer.h&quot;
#include&#32;&lt;iostream&gt;

using&#32;namespace&#32;rapidjson;
using&#32;namespace&#32;std;

void&#32;main()&#32;{
&#32;&#32;&#32;&#32;StringBuffer&#32;s;
&#32;&#32;&#32;&#32;Writer&lt;StringBuffer&gt;&#32;writer(s);
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;writer.StartObject();
&#32;&#32;&#32;&#32;writer.Key(&quot;hello&quot;);
&#32;&#32;&#32;&#32;writer.String(&quot;world&quot;);
&#32;&#32;&#32;&#32;writer.Key(&quot;t&quot;);
&#32;&#32;&#32;&#32;writer.Bool(true);
&#32;&#32;&#32;&#32;writer.Key(&quot;f&quot;);
&#32;&#32;&#32;&#32;writer.Bool(false);
&#32;&#32;&#32;&#32;writer.Key(&quot;n&quot;);
&#32;&#32;&#32;&#32;writer.Null();
&#32;&#32;&#32;&#32;writer.Key(&quot;i&quot;);
&#32;&#32;&#32;&#32;writer.Uint(123);
&#32;&#32;&#32;&#32;writer.Key(&quot;pi&quot;);
&#32;&#32;&#32;&#32;writer.Double(3.1416);
&#32;&#32;&#32;&#32;writer.Key(&quot;a&quot;);
&#32;&#32;&#32;&#32;writer.StartArray();
&#32;&#32;&#32;&#32;for&#32;(unsigned&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;4;&#32;i++)
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;writer.Uint(i);
&#32;&#32;&#32;&#32;writer.EndArray();
&#32;&#32;&#32;&#32;writer.EndObject();

&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;s.GetString()&#32;&lt;&lt;&#32;endl;
}
</computeroutput></literallayout></para>

<para><literallayout><computeroutput>{&quot;hello&quot;:&quot;world&quot;,&quot;t&quot;:true,&quot;f&quot;:false,&quot;n&quot;:null,&quot;i&quot;:123,&quot;pi&quot;:3.1416,&quot;a&quot;:[0,1,2,3]}
</computeroutput></literallayout></para>

<para>There are two <computeroutput>String()</computeroutput> and <computeroutput>Key()</computeroutput> overloads. One is the same as defined in handler concept with 3 parameters. It can handle string with null characters. Another one is the simpler version used in the above example.</para>

<para>Note that, the example code does not pass any parameters in <computeroutput>EndArray()</computeroutput> and <computeroutput>EndObject()</computeroutput>. An <computeroutput>SizeType</computeroutput> can be passed but it will be simply ignored by <computeroutput><link linkend="_class_writer">Writer</link></computeroutput>.</para>

<para>You may doubt that, why not just using <computeroutput>sprintf()</computeroutput> or <computeroutput>std::stringstream</computeroutput> to build a JSON?</para>

<para>There are various reasons:<orderedlist>
<listitem>
<para><computeroutput><link linkend="_class_writer">Writer</link></computeroutput> must output a well-formed JSON. If there is incorrect event sequence (e.g. <computeroutput>Int()</computeroutput> just after <computeroutput>StartObject()</computeroutput>), it generates assertion fail in debug mode.</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_writer_1a8b4dc44f471403a83c9959575796ceab">Writer::String()</link></computeroutput> can handle string escaping (e.g. converting code point <computeroutput>U+000A</computeroutput> to <computeroutput>\n</computeroutput>) and Unicode transcoding.</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_writer">Writer</link></computeroutput> handles number output consistently.</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_writer">Writer</link></computeroutput> implements the event handler concept. It can be used to handle events from <computeroutput>Reader</computeroutput>, <computeroutput>Document</computeroutput> or other event publisher.</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_writer">Writer</link></computeroutput> can be optimized for different platforms.</para>
</listitem></orderedlist>
</para>

<para>Anyway, using <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> API is even simpler than generating a JSON by ad hoc methods.</para>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1WriterTemplate">
<title>Template</title>

<para><computeroutput><link linkend="_class_writer">Writer</link></computeroutput> has a minor design difference to <computeroutput>Reader</computeroutput>. <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> is a template class, not a typedef. There is no <computeroutput>GenericWriter</computeroutput>. The following is the declaration.</para>

<para><literallayout><computeroutput>namespace&#32;rapidjson&#32;{

template&lt;typename&#32;OutputStream,&#32;typename&#32;SourceEncoding&#32;=&#32;UTF8&lt;&gt;,&#32;typename&#32;TargetEncoding&#32;=&#32;UTF8&lt;&gt;,&#32;typename&#32;Allocator&#32;=&#32;CrtAllocator&lt;&gt;,&#32;unsigned&#32;writeFlags&#32;=&#32;kWriteDefaultFlags&gt;
class&#32;Writer&#32;{
public:
&#32;&#32;&#32;&#32;Writer(OutputStream&amp;&#32;os,&#32;Allocator*&#32;allocator&#32;=&#32;0,&#32;size_t&#32;levelDepth&#32;=&#32;kDefaultLevelDepth)
//&#32;...
};

}&#32;//&#32;namespace&#32;rapidjson
</computeroutput></literallayout></para>

<para>The <computeroutput>OutputStream</computeroutput> template parameter is the type of output stream. It cannot be deduced and must be specified by user.</para>

<para>The <computeroutput>SourceEncoding</computeroutput> template parameter specifies the encoding to be used in <computeroutput>String(const Ch*, ...)</computeroutput>.</para>

<para>The <computeroutput>TargetEncoding</computeroutput> template parameter specifies the encoding in the output stream.</para>

<para>The <computeroutput>Allocator</computeroutput> is the type of allocator, which is used for allocating internal data structure (a stack).</para>

<para>The <computeroutput>writeFlags</computeroutput> are combination of the following bit-flags:</para>

<para><informaltable frame="all">
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<thead>
      <row  class='markdownTableHead'>
<entry>
<para>Parse flags   </para>
</entry><entry>
<para>Meaning    </para>
</entry></row>
</thead><tbody>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>kWriteNoFlags</computeroutput>   </para>
</entry><entry>
<para>No flag is set.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>kWriteDefaultFlags</computeroutput>   </para>
</entry><entry>
<para>Default write flags. It is equal to macro <computeroutput>RAPIDJSON_WRITE_DEFAULT_FLAGS</computeroutput>, which is defined as <computeroutput>kWriteNoFlags</computeroutput>.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>kWriteValidateEncodingFlag</computeroutput>   </para>
</entry><entry>
<para>Validate encoding of JSON strings.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>kWriteNanAndInfFlag</computeroutput>   </para>
</entry><entry>
<para>Allow writing of <computeroutput>Infinity</computeroutput>, <computeroutput>-Infinity</computeroutput> and <computeroutput>NaN</computeroutput>.   </para>
</entry></row>
    </tbody>
    </tgroup>
</informaltable>
</para>

<para>Besides, the constructor of <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> has a <computeroutput>levelDepth</computeroutput> parameter. This parameter affects the initial memory allocated for storing information per hierarchy level.</para>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1PrettyWriter">
<title>PrettyWriter</title>

<para>While the output of <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> is the most condensed JSON without white-spaces, suitable for network transfer or storage, it is not easily readable by human.</para>

<para>Therefore, RapidJSON provides a <computeroutput><link linkend="_class_pretty_writer">PrettyWriter</link></computeroutput>, which adds indentation and line feeds in the output.</para>

<para>The usage of <computeroutput><link linkend="_class_pretty_writer">PrettyWriter</link></computeroutput> is exactly the same as <computeroutput><link linkend="_class_writer">Writer</link></computeroutput>, expect that <computeroutput><link linkend="_class_pretty_writer">PrettyWriter</link></computeroutput> provides a <computeroutput>SetIndent(Ch indentChar, unsigned indentCharCount)</computeroutput> function. The default is 4 spaces.</para>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1CompletenessReset">
<title>Completeness and Reset</title>

<para>A <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> can only output a single JSON, which can be any JSON type at the root. Once the singular event for root (e.g. <computeroutput>String()</computeroutput>), or the last matching <computeroutput>EndObject()</computeroutput> or <computeroutput>EndArray()</computeroutput> event, is handled, the output JSON is well-formed and complete. User can detect this state by calling <computeroutput><link linkend="_class_writer_1a07d74d36dd3191b06e0aab678c246157">Writer::IsComplete()</link></computeroutput>.</para>

<para>When a JSON is complete, the <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> cannot accept any new events. Otherwise the output will be invalid (i.e. having more than one root). To reuse the <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> object, user can call <computeroutput><link linkend="_class_writer_1a8b53e8f137f7fcf694f5500711b3f58d">Writer::Reset(OutputStream&amp; os)</link></computeroutput> to reset all internal states of the <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> with a new output stream.</para>
</section>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1SaxTechniques">
<title>Techniques</title>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1CustomDataStructure">
<title>Parsing JSON to Custom Data Structure</title>

<para><computeroutput>Document</computeroutput>&apos;s parsing capability is completely based on <computeroutput>Reader</computeroutput>. Actually <computeroutput>Document</computeroutput> is a handler which receives events from a reader to build a DOM during parsing.</para>

<para>User may uses <computeroutput>Reader</computeroutput> to build other data structures directly. This eliminates building of DOM, thus reducing memory and improving performance.</para>

<para>In the following <computeroutput>messagereader</computeroutput> example, <computeroutput><link linkend="_messagereader_8cpp_1a5cd118312f7d5b3983499e2934611ebf">ParseMessages()</link></computeroutput> parses a JSON which should be an object with key-string pairs.</para>

<para><literallayout><computeroutput>#include&#32;&quot;rapidjson/reader.h&quot;
#include&#32;&quot;rapidjson/error/en.h&quot;
#include&#32;&lt;iostream&gt;
#include&#32;&lt;string&gt;
#include&#32;&lt;map&gt;

using&#32;namespace&#32;std;
using&#32;namespace&#32;rapidjson;

typedef&#32;map&lt;string,&#32;string&gt;&#32;MessageMap;

struct&#32;MessageHandler
&#32;&#32;&#32;&#32;:&#32;public&#32;BaseReaderHandler&lt;UTF8&lt;&gt;,&#32;MessageHandler&gt;&#32;{
&#32;&#32;&#32;&#32;MessageHandler()&#32;:&#32;state_(kExpectObjectStart)&#32;{
&#32;&#32;&#32;&#32;}

&#32;&#32;&#32;&#32;bool&#32;StartObject()&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;switch&#32;(state_)&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;case&#32;kExpectObjectStart:
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;state_&#32;=&#32;kExpectNameOrObjectEnd;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;true;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;default:
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;false;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
&#32;&#32;&#32;&#32;}

&#32;&#32;&#32;&#32;bool&#32;String(const&#32;char*&#32;str,&#32;SizeType&#32;length,&#32;bool)&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;switch&#32;(state_)&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;case&#32;kExpectNameOrObjectEnd:
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;name_&#32;=&#32;string(str,&#32;length);
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;state_&#32;=&#32;kExpectValue;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;true;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;case&#32;kExpectValue:
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;messages_.insert(MessageMap::value_type(name_,&#32;string(str,&#32;length)));
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;state_&#32;=&#32;kExpectNameOrObjectEnd;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;true;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;default:
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;false;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
&#32;&#32;&#32;&#32;}

&#32;&#32;&#32;&#32;bool&#32;EndObject(SizeType)&#32;{&#32;return&#32;state_&#32;==&#32;kExpectNameOrObjectEnd;&#32;}

&#32;&#32;&#32;&#32;bool&#32;Default()&#32;{&#32;return&#32;false;&#32;}&#32;//&#32;All&#32;other&#32;events&#32;are&#32;invalid.

&#32;&#32;&#32;&#32;MessageMap&#32;messages_;
&#32;&#32;&#32;&#32;enum&#32;State&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;kExpectObjectStart,
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;kExpectNameOrObjectEnd,
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;kExpectValue,
&#32;&#32;&#32;&#32;}state_;
&#32;&#32;&#32;&#32;std::string&#32;name_;
};

void&#32;ParseMessages(const&#32;char*&#32;json,&#32;MessageMap&amp;&#32;messages)&#32;{
&#32;&#32;&#32;&#32;Reader&#32;reader;
&#32;&#32;&#32;&#32;MessageHandler&#32;handler;
&#32;&#32;&#32;&#32;StringStream&#32;ss(json);
&#32;&#32;&#32;&#32;if&#32;(reader.Parse(ss,&#32;handler))
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;messages.swap(handler.messages_);&#32;&#32;&#32;//&#32;Only&#32;change&#32;it&#32;if&#32;success.
&#32;&#32;&#32;&#32;else&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ParseErrorCode&#32;e&#32;=&#32;reader.GetParseErrorCode();
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_t&#32;o&#32;=&#32;reader.GetErrorOffset();
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;&quot;Error:&#32;&quot;&#32;&lt;&lt;&#32;GetParseError_En(e)&#32;&lt;&lt;&#32;endl;;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;&quot;&#32;at&#32;offset&#32;&quot;&#32;&lt;&lt;&#32;o&#32;&lt;&lt;&#32;&quot;&#32;near&#32;&apos;&quot;&#32;&lt;&lt;&#32;string(json).substr(o,&#32;10)&#32;&lt;&lt;&#32;&quot;...&apos;&quot;&#32;&lt;&lt;&#32;endl;
&#32;&#32;&#32;&#32;}
}

int&#32;main()&#32;{
&#32;&#32;&#32;&#32;MessageMap&#32;messages;

&#32;&#32;&#32;&#32;const&#32;char*&#32;json1&#32;=&#32;&quot;{&#32;\&quot;greeting\&quot;&#32;:&#32;\&quot;Hello!\&quot;,&#32;\&quot;farewell\&quot;&#32;:&#32;\&quot;bye-bye!\&quot;&#32;}&quot;;
&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;json1&#32;&lt;&lt;&#32;endl;
&#32;&#32;&#32;&#32;ParseMessages(json1,&#32;messages);

&#32;&#32;&#32;&#32;for&#32;(MessageMap::const_iterator&#32;itr&#32;=&#32;messages.begin();&#32;itr&#32;!=&#32;messages.end();&#32;++itr)
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;itr-&gt;first&#32;&lt;&lt;&#32;&quot;:&#32;&quot;&#32;&lt;&lt;&#32;itr-&gt;second&#32;&lt;&lt;&#32;endl;

&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;endl&#32;&lt;&lt;&#32;&quot;Parse&#32;a&#32;JSON&#32;with&#32;invalid&#32;schema.&quot;&#32;&lt;&lt;&#32;endl;
&#32;&#32;&#32;&#32;const&#32;char*&#32;json2&#32;=&#32;&quot;{&#32;\&quot;greeting\&quot;&#32;:&#32;\&quot;Hello!\&quot;,&#32;\&quot;farewell\&quot;&#32;:&#32;\&quot;bye-bye!\&quot;,&#32;\&quot;foo\&quot;&#32;:&#32;{}&#32;}&quot;;
&#32;&#32;&#32;&#32;cout&#32;&lt;&lt;&#32;json2&#32;&lt;&lt;&#32;endl;
&#32;&#32;&#32;&#32;ParseMessages(json2,&#32;messages);

&#32;&#32;&#32;&#32;return&#32;0;
}
</computeroutput></literallayout></para>

<para><literallayout><computeroutput>{&#32;&quot;greeting&quot;&#32;:&#32;&quot;Hello!&quot;,&#32;&quot;farewell&quot;&#32;:&#32;&quot;bye-bye!&quot;&#32;}
farewell:&#32;bye-bye!
greeting:&#32;Hello!

Parse&#32;a&#32;JSON&#32;with&#32;invalid&#32;schema.
{&#32;&quot;greeting&quot;&#32;:&#32;&quot;Hello!&quot;,&#32;&quot;farewell&quot;&#32;:&#32;&quot;bye-bye!&quot;,&#32;&quot;foo&quot;&#32;:&#32;{}&#32;}
Error:&#32;Terminate&#32;parsing&#32;due&#32;to&#32;Handler&#32;error.
&#32;at&#32;offset&#32;59&#32;near&#32;&apos;}&#32;}...&apos;
</computeroutput></literallayout></para>

<para>The first JSON (<computeroutput>json1</computeroutput>) was successfully parsed into <computeroutput>MessageMap</computeroutput>. Since <computeroutput>MessageMap</computeroutput> is a <computeroutput>std::map</computeroutput>, the printing order are sorted by the key. This order is different from the JSON&apos;s order.</para>

<para>In the second JSON (<computeroutput>json2</computeroutput>), <computeroutput>foo</computeroutput>&apos;s value is an empty object. As it is an object, <computeroutput><link linkend="_struct_message_handler_1a3d7e691831748287252e10ced02061f5">MessageHandler::StartObject()</link></computeroutput> will be called. However, at that moment <computeroutput>state_ = kExpectValue</computeroutput>, so that function returns <computeroutput>false</computeroutput> and cause the parsing process be terminated. The error code is <computeroutput>kParseErrorTermination</computeroutput>.</para>
</section>
<section xml:id="_md_src_rapidjson_doc_sax_zh_cn_1Filtering">
<title>Filtering of JSON</title>

<para>As mentioned earlier, <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> can handle the events published by <computeroutput>Reader</computeroutput>. <computeroutput>condense</computeroutput> example simply set a <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> as handler of a <computeroutput>Reader</computeroutput>, so it can remove all white-spaces in JSON. <computeroutput>pretty</computeroutput> example uses the same relationship, but replacing <computeroutput><link linkend="_class_writer">Writer</link></computeroutput> by <computeroutput><link linkend="_class_pretty_writer">PrettyWriter</link></computeroutput>. So <computeroutput>pretty</computeroutput> can be used to reformat a JSON with indentation and line feed.</para>

<para>Actually, we can add intermediate layer(s) to filter the contents of JSON via these SAX-style API. For example, <computeroutput>capitalize</computeroutput> example capitalize all strings in a JSON.</para>

<para><literallayout><computeroutput>#include&#32;&quot;rapidjson/reader.h&quot;
#include&#32;&quot;rapidjson/writer.h&quot;
#include&#32;&quot;rapidjson/filereadstream.h&quot;
#include&#32;&quot;rapidjson/filewritestream.h&quot;
#include&#32;&quot;rapidjson/error/en.h&quot;
#include&#32;&lt;vector&gt;
#include&#32;&lt;cctype&gt;

using&#32;namespace&#32;rapidjson;

template&lt;typename&#32;OutputHandler&gt;
struct&#32;CapitalizeFilter&#32;{
&#32;&#32;&#32;&#32;CapitalizeFilter(OutputHandler&amp;&#32;out)&#32;:&#32;out_(out),&#32;buffer_()&#32;{
&#32;&#32;&#32;&#32;}

&#32;&#32;&#32;&#32;bool&#32;Null()&#32;{&#32;return&#32;out_.Null();&#32;}
&#32;&#32;&#32;&#32;bool&#32;Bool(bool&#32;b)&#32;{&#32;return&#32;out_.Bool(b);&#32;}
&#32;&#32;&#32;&#32;bool&#32;Int(int&#32;i)&#32;{&#32;return&#32;out_.Int(i);&#32;}
&#32;&#32;&#32;&#32;bool&#32;Uint(unsigned&#32;u)&#32;{&#32;return&#32;out_.Uint(u);&#32;}
&#32;&#32;&#32;&#32;bool&#32;Int64(int64_t&#32;i)&#32;{&#32;return&#32;out_.Int64(i);&#32;}
&#32;&#32;&#32;&#32;bool&#32;Uint64(uint64_t&#32;u)&#32;{&#32;return&#32;out_.Uint64(u);&#32;}
&#32;&#32;&#32;&#32;bool&#32;Double(double&#32;d)&#32;{&#32;return&#32;out_.Double(d);&#32;}
&#32;&#32;&#32;&#32;bool&#32;RawNumber(const&#32;char*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy)&#32;{&#32;return&#32;out_.RawNumber(str,&#32;length,&#32;copy);&#32;}
&#32;&#32;&#32;&#32;bool&#32;String(const&#32;char*&#32;str,&#32;SizeType&#32;length,&#32;bool)&#32;{&#32;
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer_.clear();
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;for&#32;(SizeType&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;length;&#32;i++)
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer_.push_back(std::toupper(str[i]));
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;out_.String(&amp;buffer_.front(),&#32;length,&#32;true);&#32;//&#32;true&#32;=&#32;output&#32;handler&#32;need&#32;to&#32;copy&#32;the&#32;string
&#32;&#32;&#32;&#32;}
&#32;&#32;&#32;&#32;bool&#32;StartObject()&#32;{&#32;return&#32;out_.StartObject();&#32;}
&#32;&#32;&#32;&#32;bool&#32;Key(const&#32;char*&#32;str,&#32;SizeType&#32;length,&#32;bool&#32;copy)&#32;{&#32;return&#32;String(str,&#32;length,&#32;copy);&#32;}
&#32;&#32;&#32;&#32;bool&#32;EndObject(SizeType&#32;memberCount)&#32;{&#32;return&#32;out_.EndObject(memberCount);&#32;}
&#32;&#32;&#32;&#32;bool&#32;StartArray()&#32;{&#32;return&#32;out_.StartArray();&#32;}
&#32;&#32;&#32;&#32;bool&#32;EndArray(SizeType&#32;elementCount)&#32;{&#32;return&#32;out_.EndArray(elementCount);&#32;}

&#32;&#32;&#32;&#32;OutputHandler&amp;&#32;out_;
&#32;&#32;&#32;&#32;std::vector&lt;char&gt;&#32;buffer_;
};

int&#32;main(int,&#32;char*[])&#32;{
&#32;&#32;&#32;&#32;//&#32;Prepare&#32;JSON&#32;reader&#32;and&#32;input&#32;stream.
&#32;&#32;&#32;&#32;Reader&#32;reader;
&#32;&#32;&#32;&#32;char&#32;readBuffer[65536];
&#32;&#32;&#32;&#32;FileReadStream&#32;is(stdin,&#32;readBuffer,&#32;sizeof(readBuffer));

&#32;&#32;&#32;&#32;//&#32;Prepare&#32;JSON&#32;writer&#32;and&#32;output&#32;stream.
&#32;&#32;&#32;&#32;char&#32;writeBuffer[65536];
&#32;&#32;&#32;&#32;FileWriteStream&#32;os(stdout,&#32;writeBuffer,&#32;sizeof(writeBuffer));
&#32;&#32;&#32;&#32;Writer&lt;FileWriteStream&gt;&#32;writer(os);

&#32;&#32;&#32;&#32;//&#32;JSON&#32;reader&#32;parse&#32;from&#32;the&#32;input&#32;stream&#32;and&#32;let&#32;writer&#32;generate&#32;the&#32;output.
&#32;&#32;&#32;&#32;CapitalizeFilter&lt;Writer&lt;FileWriteStream&gt;&#32;&gt;&#32;filter(writer);
&#32;&#32;&#32;&#32;if&#32;(!reader.Parse(is,&#32;filter))&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(stderr,&#32;&quot;\nError(%u):&#32;%s\n&quot;,&#32;(unsigned)reader.GetErrorOffset(),&#32;GetParseError_En(reader.GetParseErrorCode()));
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;1;
&#32;&#32;&#32;&#32;}

&#32;&#32;&#32;&#32;return&#32;0;
}
</computeroutput></literallayout></para>

<para>Note that, it is incorrect to simply capitalize the JSON as a string. For example: <literallayout><computeroutput>[&quot;Hello\nWorld&quot;]
</computeroutput></literallayout></para>

<para>Simply capitalizing the whole JSON would contain incorrect escape character: <literallayout><computeroutput>[&quot;HELLO\NWORLD&quot;]
</computeroutput></literallayout></para>

<para>The correct result by <computeroutput>capitalize</computeroutput>: <literallayout><computeroutput>[&quot;HELLO\nWORLD&quot;]
</computeroutput></literallayout></para>

<para>More complicated filters can be developed. However, since SAX-style API can only provide information about a single event at a time, user may need to book-keeping the contextual information (e.g. the path from root value, storage of other related values). Some processing may be easier to be implemented in DOM than SAX. </para>
</section>
</section>
</section>
