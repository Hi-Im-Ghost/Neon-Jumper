<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neon Jumper: 编码</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neon Jumper
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">编码 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >根据 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404</a>：</p>
<blockquote class="doxtable">
<p >&zwj;(in Introduction) JSON text is a sequence of Unicode code points.</p>
<p >翻译：JSON 文本是 Unicode 码点的序列。 </p>
</blockquote>
<p>较早的 <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</a> 申明：</p>
<blockquote class="doxtable">
<p >&zwj;(in §3) JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.</p>
<p >翻译：JSON 文本应该以 Unicode 编码。缺省的编码为 UTF-8。 </p>
</blockquote>
<blockquote class="doxtable">
<p >&zwj;(in §6) JSON may be represented using UTF-8, UTF-16, or UTF-32. When JSON is written in UTF-8, JSON is 8bit compatible. When JSON is written in UTF-16 or UTF-32, the binary content-transfer-encoding must be used.</p>
<p >翻译：JSON 可使用 UTF-8、UTF-16 或 UTF-32 表示。当 JSON 以 UTF-8 写入，该 JSON 是 8 位兼容的。当 JSON 以 UTF-16 或 UTF-32 写入，就必须使用二进制的内容传送编码。 </p>
</blockquote>
<p>RapidJSON 支持多种编码。它也能检查 JSON 的编码，以及在不同编码中进行转码。所有这些功能都是在内部实现，无需使用外部的程序库（如 <a href="http://site.icu-project.org/">ICU</a>）。</p>
<h1><a class="anchor" id="Unicode"></a>
Unicode</h1>
<p >根据 <a href="http://www.unicode.org/standard/translations/t-chinese.html">Unicode 的官方网站</a>： &gt;Unicode 给每个字符提供了一个唯一的数字， 不论是什么平台、 不论是什么程序、 不论是什么语言。</p>
<p >这些唯一数字称为码点（code point），其范围介乎 <code>0x0</code> 至 <code>0x10FFFF</code> 之间。</p>
<h2><a class="anchor" id="UTF"></a>
Unicode Transformation Format</h2>
<p >存储 Unicode 码点有多种编码方式。这些称为 Unicode 转换格式（Unicode Transformation Format, UTF）。RapidJSON 支持最常用的 UTF，包括：</p>
<ul>
<li>UTF-8：8 位可变长度编码。它把一个码点映射至 1 至 4 个字节。</li>
<li>UTF-16：16 位可变长度编码。它把一个码点映射至 1 至 2 个 16 位编码单元（即 2 至 4 个字节）。</li>
<li>UTF-32：32 位固定长度编码。它直接把码点映射至单个 32 位编码单元（即 4 字节）。</li>
</ul>
<p >对于 UTF-16 及 UTF-32 来说，字节序（endianness）是有影响的。在内存中，它们通常都是以该计算机的字节序来存储。然而，当要储存在文件中或在网上传输，我们需要指明字节序列的字节序，是小端（little endian, LE）还是大端（big-endian, BE）。</p>
<p >RapidJSON 通过 <code><a class="el" href="encodings_8h.html">rapidjson/encodings.h</a></code> 中的 struct 去提供各种编码：</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">char</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f8.html">UTF8</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">wchar_t</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f16.html">UTF16</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">wchar_t</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f16_l_e.html">UTF16LE</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">wchar_t</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f16_b_e.html">UTF16BE</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">unsigned</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f32.html">UTF32</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">unsigned</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f32_l_e.html">UTF32LE</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">unsigned</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_u_t_f32_b_e.html">UTF32BE</a>;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace rapidjson</span></div>
<div class="ttc" id="anamespacerapidjson_html"><div class="ttname"><a href="namespacerapidjson.html">rapidjson</a></div><div class="ttdoc">main RapidJSON namespace</div></div>
<div class="ttc" id="astruct_u_t_f16_b_e_html"><div class="ttname"><a href="struct_u_t_f16_b_e.html">UTF16BE</a></div><div class="ttdoc">UTF-16 big endian encoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:375</div></div>
<div class="ttc" id="astruct_u_t_f16_html"><div class="ttname"><a href="struct_u_t_f16.html">UTF16</a></div><div class="ttdoc">UTF-16 encoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:269</div></div>
<div class="ttc" id="astruct_u_t_f16_l_e_html"><div class="ttname"><a href="struct_u_t_f16_l_e.html">UTF16LE</a></div><div class="ttdoc">UTF-16 little endian encoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:342</div></div>
<div class="ttc" id="astruct_u_t_f32_b_e_html"><div class="ttname"><a href="struct_u_t_f32_b_e.html">UTF32BE</a></div><div class="ttdoc">UTF-32 big endian encoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:496</div></div>
<div class="ttc" id="astruct_u_t_f32_html"><div class="ttname"><a href="struct_u_t_f32.html">UTF32</a></div><div class="ttdoc">UTF-32 encoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:418</div></div>
<div class="ttc" id="astruct_u_t_f32_l_e_html"><div class="ttname"><a href="struct_u_t_f32_l_e.html">UTF32LE</a></div><div class="ttdoc">UTF-32 little endian enocoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:457</div></div>
<div class="ttc" id="astruct_u_t_f8_html"><div class="ttname"><a href="struct_u_t_f8.html">UTF8</a></div><div class="ttdoc">UTF-8 encoding.</div><div class="ttdef"><b>Definition:</b> encodings.h:96</div></div>
</div><!-- fragment --><p >对于在内存中的文本，我们正常会使用 <code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding.">UTF8</a></code>、<code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding.">UTF16</a></code> 或 <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding.">UTF32</a></code>。对于处理经过 I/O 的文本，我们可使用 <code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding.">UTF8</a></code>、<code><a class="el" href="struct_u_t_f16_l_e.html" title="UTF-16 little endian encoding.">UTF16LE</a></code>、<code><a class="el" href="struct_u_t_f16_b_e.html" title="UTF-16 big endian encoding.">UTF16BE</a></code>、<code><a class="el" href="struct_u_t_f32_l_e.html" title="UTF-32 little endian enocoding.">UTF32LE</a></code> 或 <code><a class="el" href="struct_u_t_f32_b_e.html" title="UTF-32 big endian encoding.">UTF32BE</a></code>。</p>
<p >当使用 DOM 风格的 API，<code><a class="el" href="class_generic_value.html" title="Represents a JSON value. Use Value for UTF8 encoding and default allocator.">GenericValue</a>&lt;Encoding&gt;</code> 及 <code><a class="el" href="class_generic_document.html" title="A document for parsing JSON text as DOM.">GenericDocument</a>&lt;Encoding&gt;</code> 里的 <code>Encoding</code> 模板参数是用于指明内存中存储的 JSON 字符串使用哪种编码。因此通常我们会在此参数中使用 <code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding.">UTF8</a></code>、<code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding.">UTF16</a></code> 或 <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding.">UTF32</a></code>。如何选择，视乎应用软件所使用的操作系统及其他程序库。例如，Windows API 使用 UTF-16 表示 Unicode 字符，而多数的 Linux 发行版本及应用软件则更喜欢 UTF-8。</p>
<p >使用 UTF-16 的 DOM 声明例子：</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_generic_document.html">GenericDocument&lt;UTF16&lt;&gt;</a> &gt; WDocument;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_generic_value.html">GenericValue&lt;UTF16&lt;&gt;</a> &gt; WValue;</div>
<div class="ttc" id="aclass_generic_document_html"><div class="ttname"><a href="class_generic_document.html">GenericDocument</a></div><div class="ttdoc">A document for parsing JSON text as DOM.</div><div class="ttdef"><b>Definition:</b> document.h:2484</div></div>
<div class="ttc" id="aclass_generic_value_html"><div class="ttname"><a href="class_generic_value.html">GenericValue</a></div><div class="ttdoc">Represents a JSON value. Use Value for UTF8 encoding and default allocator.</div><div class="ttdef"><b>Definition:</b> document.h:668</div></div>
</div><!-- fragment --><p >可以在 <a class="el" href="stream_8zh-cn_8md.html">DOM's Encoding</a> 一节看到更详细的使用例子。</p>
<h2><a class="anchor" id="CharacterType"></a>
Character Type</h2>
<p >从之前的声明中可以看到，每个编码都有一个 <code>CharType</code> 模板参数。这可能比较容易混淆，实际上，每个 <code>CharType</code> 存储一个编码单元，而不是一个字符（码点）。如之前所谈及，在 UTF-8 中一个码点可能会编码成 1 至 4 个编码单元。</p>
<p >对于 <code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding.">UTF16</a>(LE|BE)</code> 及 <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding.">UTF32</a>(LE|BE)</code> 来说，<code>CharType</code> 必须分别是一个至少 2 及 4 字节的整数类型。</p>
<p >注意 C++11 新添了 <code>char16_t</code> 及 <code>char32_t</code> 类型，也可分别用于 <code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding.">UTF16</a></code> 及 <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding.">UTF32</a></code>。</p>
<h2><a class="anchor" id="AutoUTF"></a>
AutoUTF</h2>
<p >上述所介绍的编码都是在编译期静态挷定的。换句话说，使用者必须知道内存或流之中使用了哪种编码。然而，有时候我们可能需要读写不同编码的文件，而且这些编码需要在运行时才能决定。</p>
<p ><code><a class="el" href="struct_auto_u_t_f.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type.">AutoUTF</a></code> 是为此而设计的编码。它根据输入或输出流来选择使用哪种编码。目前它应该与 <code><a class="el" href="class_encoded_input_stream.html" title="Input byte stream wrapper with a statically bound encoding.">EncodedInputStream</a></code> 及 <code><a class="el" href="class_encoded_output_stream.html" title="Output byte stream wrapper with statically bound encoding.">EncodedOutputStream</a></code> 结合使用。</p>
<h2><a class="anchor" id="ASCII"></a>
ASCII</h2>
<p >虽然 JSON 标准并未提及 <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>，有时候我们希望写入 7 位的 <a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding.">ASCII</a> JSON，以供未能处理 UTF-8 的应用程序使用。由于任 JSON 都可以把 Unicode 字符表示为 <code>\uXXXX</code> 转义序列，JSON 总是可用 <a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding.">ASCII</a> 来编码。</p>
<p >以下的例子把 UTF-8 的 DOM 写成 <a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding.">ASCII</a> 的 JSON：</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"><a class="code hl_class" href="class_generic_document.html">Document</a> d; <span class="comment">// UTF8&lt;&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_class" href="class_generic_string_buffer.html">StringBuffer</a> buffer;</div>
<div class="line"><a class="code hl_class" href="class_writer.html">Writer&lt;StringBuffer, Document::EncodingType, ASCII&lt;&gt;</a> &gt; writer(buffer);</div>
<div class="line">d.Accept(writer);</div>
<div class="line">std::cout &lt;&lt; buffer.<a class="code hl_function" href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GetString</a>();</div>
<div class="ttc" id="aclass_generic_string_buffer_html"><div class="ttname"><a href="class_generic_string_buffer.html">GenericStringBuffer&lt; UTF8&lt; char &gt;, CrtAllocator &gt;</a></div></div>
<div class="ttc" id="aclass_generic_string_buffer_html_a42079865bab1deb930c6cff7d491c719"><div class="ttname"><a href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GenericStringBuffer::GetString</a></div><div class="ttdeci">const Ch * GetString() const</div><div class="ttdef"><b>Definition:</b> stringbuffer.h:73</div></div>
<div class="ttc" id="aclass_writer_html"><div class="ttname"><a href="class_writer.html">Writer</a></div><div class="ttdoc">JSON writer.</div><div class="ttdef"><b>Definition:</b> writer.h:90</div></div>
</div><!-- fragment --><p ><a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding.">ASCII</a> 可用于输入流。当输入流包含大于 127 的字节，就会导致 <code>kParseErrorStringInvalidEncoding</code> 错误。</p>
<p ><a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding.">ASCII</a> * 不能 * 用于内存（<code>Document</code> 的编码，或 <code>Reader</code> 的目标编码)，因为它不能表示 Unicode 码点。</p>
<h1><a class="anchor" id="ValidationTranscoding"></a>
Validation &amp; Transcoding</h1>
<p >当 RapidJSON 解析一个 JSON 时，它能校验输入 JSON，判断它是否所标明编码的合法序列。要开启此选项，请把 <code>kParseValidateEncodingFlag</code> 加入 <code>parseFlags</code> 模板参数。</p>
<p >若输入编码和输出编码并不相同，<code>Reader</code> 及 <code><a class="el" href="class_writer.html" title="JSON writer.">Writer</a></code> 会算把文本转码。在这种情况下，并不需要 <code>kParseValidateEncodingFlag</code>，因为它必须解码输入序列。若序列不能被解码，它必然是不合法的。</p>
<h2><a class="anchor" id="Transcoder"></a>
Transcoder</h2>
<p >虽然 RapidJSON 的编码功能是为 JSON 解析／生成而设计，使用者也可以“滥用”它们来为非 JSON 字符串转码。</p>
<p >以下的例子把 UTF-8 字符串转码成 UTF-16：</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="encodings_8h.html">rapidjson/encodings.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;...&quot;</span>; <span class="comment">// UTF-8 string</span></div>
<div class="line"><a class="code hl_struct" href="struct_generic_string_stream.html">StringStream</a> <a class="code hl_variable" href="pointer_8h.html#adb82dfe18535e9a30aa97d275f82bd55">source</a>(s);</div>
<div class="line"><a class="code hl_class" href="class_generic_string_buffer.html">GenericStringBuffer&lt;UTF16&lt;&gt;</a> &gt; target;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> hasError = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="pointer_8h.html#adb82dfe18535e9a30aa97d275f82bd55">source</a>.Peek() != <span class="charliteral">&#39;\0&#39;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_struct" href="struct_transcoder.html">Transcoder</a>&lt;<a class="code hl_struct" href="struct_u_t_f8.html">UTF8&lt;&gt;</a>, <a class="code hl_struct" href="struct_u_t_f16.html">UTF16&lt;&gt;</a> &gt;::Transcode(<a class="code hl_variable" href="pointer_8h.html#adb82dfe18535e9a30aa97d275f82bd55">source</a>, target)) {</div>
<div class="line">        hasError = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!hasError) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* t = target.<a class="code hl_function" href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GetString</a>();</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aencodings_8h_html"><div class="ttname"><a href="encodings_8h.html">encodings.h</a></div></div>
<div class="ttc" id="apointer_8h_html_adb82dfe18535e9a30aa97d275f82bd55"><div class="ttname"><a href="pointer_8h.html#adb82dfe18535e9a30aa97d275f82bd55">source</a></div><div class="ttdeci">const CharType(&amp; source)[N]</div><div class="ttdef"><b>Definition:</b> pointer.h:1272</div></div>
<div class="ttc" id="astruct_generic_string_stream_html"><div class="ttname"><a href="struct_generic_string_stream.html">GenericStringStream</a></div><div class="ttdoc">Read-only string stream.</div><div class="ttdef"><b>Definition:</b> stream.h:154</div></div>
<div class="ttc" id="astruct_transcoder_html"><div class="ttname"><a href="struct_transcoder.html">Transcoder</a></div><div class="ttdoc">Encoding conversion.</div><div class="ttdef"><b>Definition:</b> encodings.h:658</div></div>
</div><!-- fragment --><p >你也可以用 <code><a class="el" href="struct_auto_u_t_f.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type.">AutoUTF</a></code> 及对应的流来在运行时设置内源／目的之编码。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
