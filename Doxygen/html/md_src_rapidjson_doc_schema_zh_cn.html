<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neon Jumper: Schema</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neon Jumper<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="class_schema.html">Schema</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ParsingSerialization">在解析／生成时进行校验</a><ul><li class="level2"><a href="#DomParsing">DOM 解析</a></li>
</ul>
</li>
<li class="level1"><a href="#RemoteSchema">远程 Schema</a><ul><li class="level2"><a href="#RegEx">正则表达式</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >（本功能于 v1.1.0 发布）</p>
<p >JSON <a class="el" href="class_schema.html">Schema</a> 是描述 JSON 格式的一个标准草案。一个 schema 本身也是一个 JSON。使用 JSON <a class="el" href="class_schema.html">Schema</a> 去校验 JSON，可以让你的代码安全地访问 DOM，而无须检查类型或键值是否存在等。这也能确保输出的 JSON 是符合指定的 schema。</p>
<p >RapidJSON 实现了一个 <a href="http://json-schema.org/documentation.html">JSON Schema Draft v4</a> 的校验器。若你不熟悉 JSON Schema，可以参考 <a href="http://spacetelescope.github.io/understanding-json-schema/">Understanding JSON Schema</a>。</p>
<h1><a class="anchor" id="BasicUsage"></a>
Basic Usage</h1>
<p >首先，你要把 JSON <a class="el" href="class_schema.html">Schema</a> 解析成 <code>Document</code>，再把它编译成一个 <code>SchemaDocument</code>。</p>
<p >然后，利用该 <code>SchemaDocument</code> 创建一个 <code>SchemaValidator</code>。它与 <code><a class="el" href="class_writer.html" title="JSON writer.">Writer</a></code> 相似，都是能够处理 SAX 事件的。因此，你可以用 <code>document.Accept(validator)</code> 去校验一个 JSON，然后再获取校验结果。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="schema_8h.html">rapidjson/schema.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_generic_document.html">Document</a> sd;</div>
<div class="line"><span class="keywordflow">if</span> (sd.<a class="code hl_function" href="class_generic_document.html#a901db1678f99a1b550003eed75bc380a">Parse</a>(schemaJson).<a class="code hl_function" href="class_generic_document.html#a510a0588db4eb372f5d81bc3646578fb">HasParseError</a>()) {</div>
<div class="line">    <span class="comment">// 此 schema 不是合法的 JSON</span></div>
<div class="line">    <span class="comment">// ...       </span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_class" href="class_generic_schema_document.html">SchemaDocument</a> schema(sd); <span class="comment">// 把一个 Document 编译至 SchemaDocument</span></div>
<div class="line"><span class="comment">// 之后不再需要 sd</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_generic_document.html">Document</a> d;</div>
<div class="line"><span class="keywordflow">if</span> (d.<a class="code hl_function" href="class_generic_document.html#a901db1678f99a1b550003eed75bc380a">Parse</a>(inputJson).<a class="code hl_function" href="class_generic_document.html#a510a0588db4eb372f5d81bc3646578fb">HasParseError</a>()) {</div>
<div class="line">    <span class="comment">// 输入不是一个合法的 JSON</span></div>
<div class="line">    <span class="comment">// ...       </span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_generic_schema_validator.html">SchemaValidator</a> validator(schema);</div>
<div class="line"><span class="keywordflow">if</span> (!d.Accept(validator)) {</div>
<div class="line">    <span class="comment">// 输入的 JSON 不合乎 schema</span></div>
<div class="line">    <span class="comment">// 打印诊断信息</span></div>
<div class="line">    <a class="code hl_class" href="class_generic_string_buffer.html">StringBuffer</a> sb;</div>
<div class="line">    validator.GetInvalidSchemaPointer().StringifyUriFragment(sb);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Invalid schema: %s\n&quot;</span>, sb.<a class="code hl_function" href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GetString</a>());</div>
<div class="line">    printf(<span class="stringliteral">&quot;Invalid keyword: %s\n&quot;</span>, validator.GetInvalidSchemaKeyword());</div>
<div class="line">    sb.<a class="code hl_function" href="class_generic_string_buffer.html#a42f15c959046d899cb74c3120a6995f9">Clear</a>();</div>
<div class="line">    validator.GetInvalidDocumentPointer().StringifyUriFragment(sb);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Invalid document: %s\n&quot;</span>, sb.<a class="code hl_function" href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GetString</a>());</div>
<div class="line">}</div>
<div class="ttc" id="aclass_generic_document_html"><div class="ttname"><a href="class_generic_document.html">GenericDocument&lt; UTF8&lt;&gt; &gt;</a></div></div>
<div class="ttc" id="aclass_generic_document_html_a510a0588db4eb372f5d81bc3646578fb"><div class="ttname"><a href="class_generic_document.html#a510a0588db4eb372f5d81bc3646578fb">GenericDocument::HasParseError</a></div><div class="ttdeci">bool HasParseError() const</div><div class="ttdoc">Whether a parse error has occurred in the last parsing.</div><div class="ttdef"><b>Definition:</b> document.h:2755</div></div>
<div class="ttc" id="aclass_generic_document_html_a901db1678f99a1b550003eed75bc380a"><div class="ttname"><a href="class_generic_document.html#a901db1678f99a1b550003eed75bc380a">GenericDocument::Parse</a></div><div class="ttdeci">GenericDocument &amp; Parse(const typename SourceEncoding::Ch *str)</div><div class="ttdoc">Parse JSON text from a read-only string (with Encoding conversion)</div><div class="ttdef"><b>Definition:</b> document.h:2692</div></div>
<div class="ttc" id="aclass_generic_schema_document_html"><div class="ttname"><a href="class_generic_schema_document.html">GenericSchemaDocument</a></div><div class="ttdoc">JSON schema document.</div><div class="ttdef"><b>Definition:</b> schema.h:1619</div></div>
<div class="ttc" id="aclass_generic_schema_validator_html"><div class="ttname"><a href="class_generic_schema_validator.html">GenericSchemaValidator</a></div><div class="ttdoc">JSON Schema Validator.</div><div class="ttdef"><b>Definition:</b> schema.h:1992</div></div>
<div class="ttc" id="aclass_generic_string_buffer_html"><div class="ttname"><a href="class_generic_string_buffer.html">GenericStringBuffer&lt; UTF8&lt; char &gt;, CrtAllocator &gt;</a></div></div>
<div class="ttc" id="aclass_generic_string_buffer_html_a42079865bab1deb930c6cff7d491c719"><div class="ttname"><a href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GenericStringBuffer::GetString</a></div><div class="ttdeci">const Ch * GetString() const</div><div class="ttdef"><b>Definition:</b> stringbuffer.h:73</div></div>
<div class="ttc" id="aclass_generic_string_buffer_html_a42f15c959046d899cb74c3120a6995f9"><div class="ttname"><a href="class_generic_string_buffer.html#a42f15c959046d899cb74c3120a6995f9">GenericStringBuffer::Clear</a></div><div class="ttdeci">void Clear()</div><div class="ttdef"><b>Definition:</b> stringbuffer.h:60</div></div>
<div class="ttc" id="aschema_8h_html"><div class="ttname"><a href="schema_8h.html">schema.h</a></div></div>
</div><!-- fragment --><p >一些注意点：</p>
<ul>
<li>一个 <code>SchemaDocment</code> 能被多个 <code>SchemaValidator</code> 引用。它不会被 <code>SchemaValidator</code> 修改。</li>
<li>可以重复使用一个 <code>SchemaValidator</code> 来校验多个文件。在校验其他文件前，须先调用 <code>validator.Reset()</code>。</li>
</ul>
<h1><a class="anchor" id="ParsingSerialization"></a>
在解析／生成时进行校验</h1>
<p >与大部分 JSON <a class="el" href="class_schema.html">Schema</a> 校验器有所不同，RapidJSON 提供了一个基于 SAX 的 schema 校验器实现。因此，你可以在输入流解析 JSON 的同时进行校验。若校验器遇到一个与 schema 不符的值，就会立即终止解析。这设计对于解析大型 JSON 文件时特别有用。</p>
<h2><a class="anchor" id="DomParsing"></a>
DOM 解析</h2>
<p >在使用 DOM 进行解析时，<code>Document</code> 除了接收 SAX 事件外，还需做一些准备及结束工作，因此，为了连接 <code>Reader</code>、<code>SchemaValidator</code> 和 <code>Document</code> 要做多一点事情。<code><a class="el" href="class_schema_validating_reader.html" title="A helper class for parsing with validation.">SchemaValidatingReader</a></code> 是一个辅助类去做那些工作。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_class" href="class_generic_schema_document.html">SchemaDocument</a> schema(sd); <span class="comment">// 把一个 Document 编译至 SchemaDocument</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用 reader 解析 JSON</span></div>
<div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;big.json&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="class_file_read_stream.html">FileReadStream</a> is(fp, buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 用 reader 解析 JSON，校验它的 SAX 事件，并存储至 d</span></div>
<div class="line"><a class="code hl_class" href="class_generic_document.html">Document</a> d;</div>
<div class="line"><a class="code hl_class" href="class_schema_validating_reader.html">SchemaValidatingReader&lt;kParseDefaultFlags, FileReadStream, UTF8&lt;&gt;</a> &gt; reader(is, schema);</div>
<div class="line">d.<a class="code hl_function" href="class_generic_document.html#ac30b4e8887974060b695be20c3ceb02c">Populate</a>(reader);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!reader.GetParseResult()) {</div>
<div class="line">    <span class="comment">// 不是一个合法的 JSON</span></div>
<div class="line">    <span class="comment">// 当 reader.GetParseResult().Code() == kParseErrorTermination,</span></div>
<div class="line">    <span class="comment">// 它可能是被以下原因中止：</span></div>
<div class="line">    <span class="comment">// (1) 校验器发现 JSON 不合乎 schema；或</span></div>
<div class="line">    <span class="comment">// (2) 输入流有 I/O 错误。</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 检查校验结果</span></div>
<div class="line">    <span class="keywordflow">if</span> (!reader.IsValid()) {</div>
<div class="line">        <span class="comment">// 输入的 JSON 不合乎 schema</span></div>
<div class="line">        <span class="comment">// 打印诊断信息</span></div>
<div class="line">        <a class="code hl_class" href="class_generic_string_buffer.html">StringBuffer</a> sb;</div>
<div class="line">        reader.GetInvalidSchemaPointer().StringifyUriFragment(sb);</div>
<div class="line">        printf(<span class="stringliteral">&quot;Invalid schema: %s\n&quot;</span>, sb.<a class="code hl_function" href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GetString</a>());</div>
<div class="line">        printf(<span class="stringliteral">&quot;Invalid keyword: %s\n&quot;</span>, reader.GetInvalidSchemaKeyword());</div>
<div class="line">        sb.<a class="code hl_function" href="class_generic_string_buffer.html#a42f15c959046d899cb74c3120a6995f9">Clear</a>();</div>
<div class="line">        reader.GetInvalidDocumentPointer().StringifyUriFragment(sb);</div>
<div class="line">        printf(<span class="stringliteral">&quot;Invalid document: %s\n&quot;</span>, sb.<a class="code hl_function" href="class_generic_string_buffer.html#a42079865bab1deb930c6cff7d491c719">GetString</a>());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_file_read_stream_html"><div class="ttname"><a href="class_file_read_stream.html">FileReadStream</a></div><div class="ttdoc">File byte stream for input using fread().</div><div class="ttdef"><b>Definition:</b> filereadstream.h:34</div></div>
<div class="ttc" id="aclass_generic_document_html_ac30b4e8887974060b695be20c3ceb02c"><div class="ttname"><a href="class_generic_document.html#ac30b4e8887974060b695be20c3ceb02c">GenericDocument::Populate</a></div><div class="ttdeci">GenericDocument &amp; Populate(Generator &amp;g)</div><div class="ttdoc">Populate this document by a generator which produces SAX events.</div><div class="ttdef"><b>Definition:</b> document.h:2606</div></div>
<div class="ttc" id="aclass_schema_validating_reader_html"><div class="ttname"><a href="class_schema_validating_reader.html">SchemaValidatingReader</a></div><div class="ttdoc">A helper class for parsing with validation.</div><div class="ttdef"><b>Definition:</b> schema.h:2733</div></div>
<div class="ttc" id="afilereadstream_8h_html"><div class="ttname"><a href="filereadstream_8h.html">filereadstream.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="SaxParsing"></a>
Parsing</h2>
<p >使用 SAX 解析时，情况就简单得多。若只需要校验 JSON 而无需进一步处理，那么仅需要：</p>
<div class="fragment"><div class="line">SchemaValidator validator(schema);</div>
<div class="line">Reader reader;</div>
<div class="line">if (!reader.Parse(stream, validator)) {</div>
<div class="line">    if (!validator.IsValid()) {</div>
<div class="line">        // ...    </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >这种方式和 <a href="example/schemavalidator/schemavalidator.cpp">schemavalidator</a> 例子完全相同。这带来的独特优势是，无论 JSON 多巨大，永远维持低内存用量（内存用量只与 <a class="el" href="class_schema.html">Schema</a> 的复杂度相关）。</p>
<p >若你需要进一步处理 SAX 事件，便可使用模板类 <code><a class="el" href="class_generic_schema_validator.html" title="JSON Schema Validator.">GenericSchemaValidator</a></code> 去设置校验器的输出 <code>Handler</code>：</p>
<div class="fragment"><div class="line">MyHandler handler;</div>
<div class="line">GenericSchemaValidator&lt;SchemaDocument, MyHandler&gt; validator(schema, handler);</div>
<div class="line">Reader reader;</div>
<div class="line">if (!reader.Parse(ss, validator)) {</div>
<div class="line">    if (!validator.IsValid()) {</div>
<div class="line">        // ...    </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Serialization"></a>
Serialization</h2>
<p >我们也可以在生成（serialization）的时候进行校验。这能确保输出的 JSON 符合一个 JSON Schema。</p>
<div class="fragment"><div class="line">StringBuffer sb;</div>
<div class="line">Writer&lt;StringBuffer&gt; writer(sb);</div>
<div class="line">GenericSchemaValidator&lt;SchemaDocument, Writer&lt;StringBuffer&gt; &gt; validator(s, writer);</div>
<div class="line">if (!d.Accept(validator)) {</div>
<div class="line">    // Some problem during Accept(), it may be validation or encoding issues.</div>
<div class="line">    if (!validator.IsValid()) {</div>
<div class="line">        // ...</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >当然，如果你的应用仅需要 SAX 风格的生成，那么只需要把 SAX 事件由原来发送到 <code><a class="el" href="class_writer.html" title="JSON writer.">Writer</a></code>，改为发送到 <code>SchemaValidator</code>。</p>
<h1><a class="anchor" id="RemoteSchema"></a>
远程 Schema</h1>
<p >JSON <a class="el" href="class_schema.html">Schema</a> 支持 <a href="http://spacetelescope.github.io/understanding-json-schema/structuring.html"><code>$ref</code> 关键字</a>，它是一个 <a class="el" href="pointer_8zh-cn_8md.html">JSON pointer</a> 引用至一个本地（local）或远程（remote） schema。本地指针的首字符是 <code>#</code>，而远程指针是一个相对或绝对 URI。例如：</p>
<div class="fragment"><div class="line">{ &quot;$ref&quot;: &quot;definitions.json#/address&quot; }</div>
</div><!-- fragment --><p >由于 <code>SchemaDocument</code> 并不知道如何处理那些 URI，它需要使用者提供一个 <code>IRemoteSchemaDocumentProvider</code> 的实例去处理。</p>
<div class="fragment"><div class="line">class MyRemoteSchemaDocumentProvider : public IRemoteSchemaDocumentProvider {</div>
<div class="line">public:</div>
<div class="line">    virtual const SchemaDocument* GetRemoteDocument(const char* uri, SizeType length) {</div>
<div class="line">        // Resolve the uri and returns a pointer to that schema.</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">MyRemoteSchemaDocumentProvider provider;</div>
<div class="line">SchemaDocument schema(sd, &amp;provider);</div>
</div><!-- fragment --><h1><a class="anchor" id="Conformance"></a>
Conformance</h1>
<p >RapidJSON 通过了 <a href="https://github.com/json-schema/JSON-Schema-Test-Suite">JSON Schema Test Suite</a> (Json <a class="el" href="class_schema.html">Schema</a> draft 4) 中 263 个测试的 262 个。</p>
<p >没通过的测试是 <code>refRemote.json</code> 中的 "change resolution scope" - "changed scope ref invalid"。这是由于未实现 <code>id</code> schema 关键字及 URI 合并功能。</p>
<p >除此以外，关于字符串类型的 <code>format</code> schema 关键字也会被忽略，因为标准中并没需求必须实现。</p>
<h2><a class="anchor" id="RegEx"></a>
正则表达式</h2>
<p ><code>pattern</code> 及 <code>patternProperties</code> 这两个 schema 关键字使用了正则表达式去匹配所需的模式。</p>
<p >RapidJSON 实现了一个简单的 NFA 正则表达式引擎，并预设使用。它支持以下语法。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">语法   </th><th class="markdownTableHeadNone">描述    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ab</code>   </td><td class="markdownTableBodyNone">串联    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>a&amp;#124;b</code>   </td><td class="markdownTableBodyNone">交替    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>a?</code>   </td><td class="markdownTableBodyNone">零或一次    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>a*</code>   </td><td class="markdownTableBodyNone">零或多次    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>a+</code>   </td><td class="markdownTableBodyNone">一或多次    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>a{3}</code>   </td><td class="markdownTableBodyNone">刚好 3 次    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>a{3,}</code>   </td><td class="markdownTableBodyNone">至少 3 次    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>a{3,5}</code>   </td><td class="markdownTableBodyNone">3 至 5 次    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>(ab)</code>   </td><td class="markdownTableBodyNone">分组    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>^a</code>   </td><td class="markdownTableBodyNone">在开始处    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>a$</code>   </td><td class="markdownTableBodyNone">在结束处    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.</code>   </td><td class="markdownTableBodyNone">任何字符    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[abc]</code>   </td><td class="markdownTableBodyNone">字符组    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[a-c]</code>   </td><td class="markdownTableBodyNone">字符组范围    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[a-z0-9_]</code>   </td><td class="markdownTableBodyNone">字符组组合    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[^abc]</code>   </td><td class="markdownTableBodyNone">字符组取反    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[^a-c]</code>   </td><td class="markdownTableBodyNone">字符组范围取反    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[\b]</code>   </td><td class="markdownTableBodyNone">退格符 (U+0008)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>\&amp;#124;</code>, <code>\\</code>, ...   </td><td class="markdownTableBodyNone">转义字符    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>\f</code>   </td><td class="markdownTableBodyNone">馈页 (U+000C)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>\n</code>   </td><td class="markdownTableBodyNone">馈行 (U+000A)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>\r</code>   </td><td class="markdownTableBodyNone">回车 (U+000D)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>\t</code>   </td><td class="markdownTableBodyNone">制表 (U+0009)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>\v</code>   </td><td class="markdownTableBodyNone">垂直制表 (U+000B)   </td></tr>
</table>
<p >对于使用 C++11 编译器的使用者，也可使用 <code>std::regex</code>，只需定义 <code>RAPIDJSON_SCHEMA_USE_INTERNALREGEX=0</code> 及 <code>RAPIDJSON_SCHEMA_USE_STDREGEX=1</code>。若你的 schema 无需使用 <code>pattern</code> 或 <code>patternProperties</code>，可以把两个宏都设为零，以禁用此功能，这样做可节省一些代码体积。</p>
<h1><a class="anchor" id="Performance"></a>
Performance</h1>
<p >大部分 C++ JSON 库都未支持 JSON Schema。因此我们尝试按照 <a href="https://github.com/ebdrup/json-schema-benchmark">json-schema-benchmark</a> 去评估 RapidJSON 的 JSON <a class="el" href="class_schema.html">Schema</a> 校验器。该评测测试了 11 个运行在 node.js 上的 JavaScript 库。</p>
<p >该评测校验 <a href="https://github.com/json-schema/JSON-Schema-Test-Suite">JSON Schema Test Suite</a> 中的测试，当中排除了一些测试套件及个别测试。我们在 <a href="test/perftest/schematest.cpp"><code>schematest.cpp</code></a> 实现了相同的评测。</p>
<p >在 MacBook Pro (2.8 GHz Intel Core i7) 上收集到以下结果。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">校验器   </th><th class="markdownTableHeadCenter">相对速度   </th><th class="markdownTableHeadCenter">每秒执行的测试数目    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RapidJSON   </td><td class="markdownTableBodyCenter">155%   </td><td class="markdownTableBodyCenter">30682    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/epoberezkin/ajv"><code>ajv</code></a>   </td><td class="markdownTableBodyCenter">100%   </td><td class="markdownTableBodyCenter">19770 (± 1.31%)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/mafintosh/is-my-json-valid"><code>is-my-json-valid</code></a>   </td><td class="markdownTableBodyCenter">70%   </td><td class="markdownTableBodyCenter">13835 (± 2.84%)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/bugventure/jsen"><code>jsen</code></a>   </td><td class="markdownTableBodyCenter">57.7%   </td><td class="markdownTableBodyCenter">11411 (± 1.27%)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/AlexeyGrishin/schemasaurus"><code>schemasaurus</code></a>   </td><td class="markdownTableBodyCenter">26%   </td><td class="markdownTableBodyCenter">5145 (± 1.62%)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/playlyfe/themis"><code>themis</code></a>   </td><td class="markdownTableBodyCenter">19.9%   </td><td class="markdownTableBodyCenter">3935 (± 2.69%)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/zaggino/z-schema"><code>z-schema</code></a>   </td><td class="markdownTableBodyCenter">7%   </td><td class="markdownTableBodyCenter">1388 (± 0.84%)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/pandastrike/jsck#readme"><code>jsck</code></a>   </td><td class="markdownTableBodyCenter">3.1%   </td><td class="markdownTableBodyCenter">606 (± 2.84%)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/tdegrunt/jsonschema#readme"><code>jsonschema</code></a>   </td><td class="markdownTableBodyCenter">0.9%   </td><td class="markdownTableBodyCenter">185 (± 1.01%)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/Prestaul/skeemas#readme"><code>skeemas</code></a>   </td><td class="markdownTableBodyCenter">0.8%   </td><td class="markdownTableBodyCenter">154 (± 0.79%)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tv4   </td><td class="markdownTableBodyCenter">0.5%   </td><td class="markdownTableBodyCenter">93 (± 0.94%)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/natesilva/jayschema"><code>jayschema</code></a>   </td><td class="markdownTableBodyCenter">0.1%   </td><td class="markdownTableBodyCenter">21 (± 1.14%)   </td></tr>
</table>
<p >换言之，RapidJSON 比最快的 JavaScript 库（ajv）快约 1.5x。比最慢的快 1400x。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
