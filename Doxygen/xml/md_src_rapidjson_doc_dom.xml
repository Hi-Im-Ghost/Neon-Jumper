<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="md_src_rapidjson_doc_dom" kind="page">
    <compoundname>md_src_rapidjson_doc_dom</compoundname>
    <title>DOM</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Document Object Model(DOM) is an in-memory representation of JSON for query and manipulation. The basic usage of DOM is described in <ref refid="tutorial_8md" kindref="compound">Tutorial</ref>. This section will describe some details and more advanced usages.</para>
<sect1 id="md_src_rapidjson_doc_dom_zh_cn_1Template">
<title>Template</title>
<para>In the tutorial, <computeroutput>Value</computeroutput> and <computeroutput>Document</computeroutput> was used. Similarly to <computeroutput>std::string</computeroutput>, these are actually <computeroutput>typedef</computeroutput> of template classes:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespacerapidjson" kindref="compound">rapidjson</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Encoding,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Allocator<sp/>=<sp/>MemoryPoolAllocator&lt;&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="class_generic_value" kindref="compound">GenericValue</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Encoding,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Allocator<sp/>=<sp/>MemoryPoolAllocator&lt;&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="class_generic_value" kindref="compound">GenericValue</ref>&lt;Encoding,<sp/>Allocator&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="class_generic_value" kindref="compound">GenericValue&lt;UTF8&lt;&gt;</ref><sp/>&gt;<sp/><ref refid="document_8h_1a071cf97155ba72ac9a1fc4ad7e63d481" kindref="member">Value</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="class_generic_document" kindref="compound">GenericDocument&lt;UTF8&lt;&gt;</ref><sp/>&gt;<sp/><ref refid="document_8h_1ac6ea5b168e3fe8c7fa532450fc9391f7" kindref="member">Document</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>rapidjson</highlight></codeline>
</programlisting></para>
<para>User can customize these template parameters.</para>
<sect2 id="md_src_rapidjson_doc_dom_zh_cn_1Encoding">
<title>Encoding</title>
<para>The <computeroutput>Encoding</computeroutput> parameter specifies the encoding of JSON String value in memory. Possible options are <computeroutput><ref refid="struct_u_t_f8" kindref="compound">UTF8</ref></computeroutput>, <computeroutput><ref refid="struct_u_t_f16" kindref="compound">UTF16</ref></computeroutput>, <computeroutput><ref refid="struct_u_t_f32" kindref="compound">UTF32</ref></computeroutput>. Note that, these 3 types are also template class. <computeroutput><ref refid="struct_u_t_f8" kindref="compound">UTF8</ref>&lt;&gt;</computeroutput> is <computeroutput><ref refid="struct_u_t_f8" kindref="compound">UTF8</ref>&lt;char&gt;</computeroutput>, which means using char to store the characters. You may refer to <ref refid="encoding_8md" kindref="compound">Encoding</ref> for details.</para>
<para>Suppose a Windows application would query localization strings stored in JSON files. Unicode-enabled functions in Windows use UTF-16 (wide character) encoding. No matter what encoding was used in JSON files, we can store the strings in UTF-16 in memory.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacerapidjson" kindref="compound">rapidjson</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="class_generic_document" kindref="compound">GenericDocument&lt;UTF16&lt;&gt;</ref><sp/>&gt;<sp/>WDocument;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="class_generic_value" kindref="compound">GenericValue&lt;UTF16&lt;&gt;</ref><sp/>&gt;<sp/>WValue;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>fp<sp/>=<sp/>fopen(</highlight><highlight class="stringliteral">&quot;localization.json&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;rb&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>non-Windows<sp/>use<sp/>&quot;r&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>readBuffer[256];</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_file_read_stream" kindref="compound">FileReadStream</ref><sp/>bis(fp,<sp/>readBuffer,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(readBuffer));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_auto_u_t_f_input_stream" kindref="compound">AutoUTFInputStream&lt;unsigned, FileReadStream&gt;</ref><sp/>eis(bis);<sp/><sp/></highlight><highlight class="comment">//<sp/>wraps<sp/>bis<sp/>into<sp/>eis</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">WDocument<sp/>d;</highlight></codeline>
<codeline><highlight class="normal">d.ParseStream&lt;0,<sp/><ref refid="struct_auto_u_t_f" kindref="compound">AutoUTF&lt;unsigned&gt;</ref><sp/>&gt;(eis);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>WValue<sp/>locale(L</highlight><highlight class="stringliteral">&quot;ja&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>Japanese</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MessageBoxW(hWnd,<sp/>d[locale].GetString(),<sp/>L</highlight><highlight class="stringliteral">&quot;Test&quot;</highlight><highlight class="normal">,<sp/>MB_OK);</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src_rapidjson_doc_dom_zh_cn_1Allocator">
<title>Allocator</title>
<para>The <computeroutput>Allocator</computeroutput> defines which allocator class is used when allocating/deallocating memory for <computeroutput>Document</computeroutput>/<computeroutput>Value</computeroutput>. <computeroutput>Document</computeroutput> owns, or references to an <computeroutput>Allocator</computeroutput> instance. On the other hand, <computeroutput>Value</computeroutput> does not do so, in order to reduce memory consumption.</para>
<para>The default allocator used in <computeroutput><ref refid="class_generic_document" kindref="compound">GenericDocument</ref></computeroutput> is <computeroutput><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator</ref></computeroutput>. This allocator actually allocate memory sequentially, and cannot deallocate one by one. This is very suitable when parsing a JSON into a DOM tree.</para>
<para>Another allocator is <computeroutput><ref refid="class_crt_allocator" kindref="compound">CrtAllocator</ref></computeroutput>, of which CRT is short for C RunTime library. This allocator simply calls the standard <computeroutput>malloc()</computeroutput>/<computeroutput>realloc()</computeroutput>/<computeroutput>free()</computeroutput>. When there is a lot of add and remove operations, this allocator may be preferred. But this allocator is far less efficient than <computeroutput><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator</ref></computeroutput>.</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_dom_zh_cn_1Parsing">
<title>Parsing</title>
<para><computeroutput>Document</computeroutput> provides several functions for parsing. In below, (1) is the fundamental function, while the others are helpers which call (1).</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacerapidjson" kindref="compound">rapidjson</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(1)<sp/>Fundamental</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>parseFlags,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SourceEncoding,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>InputStream&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a7bc1827a7ab04de4789fe46237f0e921" kindref="member">GenericDocument::ParseStream</ref>(InputStream&amp;<sp/>is);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(2)<sp/>Using<sp/>the<sp/>same<sp/>Encoding<sp/>for<sp/>stream</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>parseFlags,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>InputStream&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a7bc1827a7ab04de4789fe46237f0e921" kindref="member">GenericDocument::ParseStream</ref>(InputStream&amp;<sp/>is);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(3)<sp/>Using<sp/>default<sp/>parse<sp/>flags</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>InputStream&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a7bc1827a7ab04de4789fe46237f0e921" kindref="member">GenericDocument::ParseStream</ref>(InputStream&amp;<sp/>is);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(4)<sp/>In<sp/>situ<sp/>parsing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>parseFlags&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a13f68b1896a24eea4cdbc03a3916225f" kindref="member">GenericDocument::ParseInsitu</ref>(Ch*<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(5)<sp/>In<sp/>situ<sp/>parsing,<sp/>using<sp/>default<sp/>parse<sp/>flags</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a13f68b1896a24eea4cdbc03a3916225f" kindref="member">GenericDocument::ParseInsitu</ref>(Ch*<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(6)<sp/>Normal<sp/>parsing<sp/>of<sp/>a<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>parseFlags,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SourceEncoding&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">GenericDocument::Parse</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Ch*<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(7)<sp/>Normal<sp/>parsing<sp/>of<sp/>a<sp/>string,<sp/>using<sp/>same<sp/>Encoding<sp/>of<sp/>Document</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>parseFlags&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">GenericDocument::Parse</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Ch*<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(8)<sp/>Normal<sp/>parsing<sp/>of<sp/>a<sp/>string,<sp/>using<sp/>default<sp/>parse<sp/>flags</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">GenericDocument</ref>&amp;<sp/><ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">GenericDocument::Parse</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Ch*<sp/>str);</highlight></codeline>
</programlisting></para>
<para>The examples of <ref refid="tutorial_8md" kindref="compound">tutorial</ref> uses (8) for normal parsing of string. The examples of <ref refid="stream_8md" kindref="compound">stream</ref> uses the first three. <emphasis>In situ</emphasis> parsing will be described soon.</para>
<para>The <computeroutput>parseFlags</computeroutput> are combination of the following bit-flags:</para>
<para><table rows="13" cols="2"><row>
<entry thead="yes"><para>Parse flags   </para>
</entry><entry thead="yes"><para>Meaning    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseNoFlags</computeroutput>   </para>
</entry><entry thead="no"><para>No flag is set.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseDefaultFlags</computeroutput>   </para>
</entry><entry thead="no"><para>Default parse flags. It is equal to macro <computeroutput>RAPIDJSON_PARSE_DEFAULT_FLAGS</computeroutput>, which is defined as <computeroutput>kParseNoFlags</computeroutput>.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseInsituFlag</computeroutput>   </para>
</entry><entry thead="no"><para>In-situ(destructive) parsing.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseValidateEncodingFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Validate encoding of JSON strings.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseIterativeFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Iterative(constant complexity in terms of function call stack size) parsing.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseStopWhenDoneFlag</computeroutput>   </para>
</entry><entry thead="no"><para>After parsing a complete JSON root from stream, stop further processing the rest of stream. When this flag is used, parser will not generate <computeroutput>kParseErrorDocumentRootNotSingular</computeroutput> error. Using this flag for parsing multiple JSONs in the same stream.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseFullPrecisionFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Parse number in full precision (slower). If this flag is not set, the normal precision (faster) is used. Normal precision has maximum 3 <ulink url="http://en.wikipedia.org/wiki/Unit_in_the_last_place">ULP</ulink> error.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseCommentsFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Allow one-line <computeroutput>// ...</computeroutput> and multi-line <computeroutput>/* ... */</computeroutput> comments (relaxed JSON syntax).    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseNumbersAsStringsFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Parse numerical type values as strings.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseTrailingCommasFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Allow trailing commas at the end of objects and arrays (relaxed JSON syntax).    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseNanAndInfFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Allow parsing <computeroutput>NaN</computeroutput>, <computeroutput>Inf</computeroutput>, <computeroutput>Infinity</computeroutput>, <computeroutput>-Inf</computeroutput> and <computeroutput>-Infinity</computeroutput> as <computeroutput>double</computeroutput> values (relaxed JSON syntax).    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseEscapedApostropheFlag</computeroutput>   </para>
</entry><entry thead="no"><para>Allow escaped apostrophe <lsquo/>&amp;rsquo;` in strings (relaxed JSON syntax).   </para>
</entry></row>
</table>
</para>
<para>By using a non-type template parameter, instead of a function parameter, C++ compiler can generate code which is optimized for specified combinations, improving speed, and reducing code size (if only using a single specialization). The downside is the flags needed to be determined in compile-time.</para>
<para>The <computeroutput>SourceEncoding</computeroutput> parameter defines what encoding is in the stream. This can be differed to the <computeroutput>Encoding</computeroutput> of the <computeroutput>Document</computeroutput>. See <ref refid="md_src_rapidjson_doc_dom_zh_cn_1TranscodingAndValidation" kindref="member">Transcoding and Validation</ref> section for details.</para>
<para>And the <computeroutput>InputStream</computeroutput> is type of input stream.</para>
<sect2 id="md_src_rapidjson_doc_dom_zh_cn_1ParseError">
<title>Parse Error</title>
<para>When the parse processing succeeded, the <computeroutput>Document</computeroutput> contains the parse results. When there is an error, the original DOM is <emphasis>unchanged</emphasis>. And the error state of parsing can be obtained by <computeroutput>bool HasParseError()</computeroutput>, <computeroutput>ParseErrorCode GetParseError()</computeroutput> and <computeroutput>size_t GetErrorOffset()</computeroutput>.</para>
<para><table rows="17" cols="2"><row>
<entry thead="yes"><para>Parse Error Code   </para>
</entry><entry thead="yes"><para>Description    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorNone</computeroutput>   </para>
</entry><entry thead="no"><para>No error.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorDocumentEmpty</computeroutput>   </para>
</entry><entry thead="no"><para>The document is empty.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorDocumentRootNotSingular</computeroutput>   </para>
</entry><entry thead="no"><para>The document root must not follow by other values.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorValueInvalid</computeroutput>   </para>
</entry><entry thead="no"><para>Invalid value.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorObjectMissName</computeroutput>   </para>
</entry><entry thead="no"><para>Missing a name for object member.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorObjectMissColon</computeroutput>   </para>
</entry><entry thead="no"><para>Missing a colon after a name of object member.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorObjectMissCommaOrCurlyBracket</computeroutput>   </para>
</entry><entry thead="no"><para>Missing a comma or <computeroutput>}</computeroutput> after an object member.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorArrayMissCommaOrSquareBracket</computeroutput>   </para>
</entry><entry thead="no"><para>Missing a comma or <computeroutput>]</computeroutput> after an array element.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorStringUnicodeEscapeInvalidHex</computeroutput>   </para>
</entry><entry thead="no"><para>Incorrect hex digit after <computeroutput>\\u</computeroutput> escape in string.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorStringUnicodeSurrogateInvalid</computeroutput>   </para>
</entry><entry thead="no"><para>The surrogate pair in string is invalid.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorStringEscapeInvalid</computeroutput>   </para>
</entry><entry thead="no"><para>Invalid escape character in string.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorStringMissQuotationMark</computeroutput>   </para>
</entry><entry thead="no"><para>Missing a closing quotation mark in string.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorStringInvalidEncoding</computeroutput>   </para>
</entry><entry thead="no"><para>Invalid encoding in string.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorNumberTooBig</computeroutput>   </para>
</entry><entry thead="no"><para>Number too big to be stored in <computeroutput>double</computeroutput>.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorNumberMissFraction</computeroutput>   </para>
</entry><entry thead="no"><para>Miss fraction part in number.    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>kParseErrorNumberMissExponent</computeroutput>   </para>
</entry><entry thead="no"><para>Miss exponent in number.   </para>
</entry></row>
</table>
</para>
<para>The offset of error is defined as the character number from beginning of stream. Currently RapidJSON does not keep track of line number.</para>
<para>To get an error message, RapidJSON provided a English messages in <computeroutput><ref refid="en_8h" kindref="compound">rapidjson/error/en.h</ref></computeroutput>. User can customize it for other locales, or use a custom localization system.</para>
<para>Here shows an example of parse error handling.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&quot;<ref refid="document_8h" kindref="compound">rapidjson/document.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="en_8h" kindref="compound">rapidjson/error/en.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">Document</ref><sp/>d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d.<ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">Parse</ref>(json).<ref refid="class_generic_document_1a510a0588db4eb372f5d81bc3646578fb" kindref="member">HasParseError</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;\nError(offset<sp/>%u):<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal">)d.<ref refid="class_generic_document_1ae1ef7ca99ced428e9300c68e5142afdb" kindref="member">GetErrorOffset</ref>(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_1ga28835eb93d2c3c07bbea13515eb31415" kindref="member">GetParseError_En</ref>(d.<ref refid="class_generic_document_1a9400a5bd3169cc6ed545e681ccc06070" kindref="member">GetParseError</ref>()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src_rapidjson_doc_dom_zh_cn_1InSituParsing">
<title>In Situ Parsing</title>
<para>From <ulink url="http://en.wikipedia.org/wiki/In_situ">Wikipedia</ulink>:</para>
<para><blockquote><para><zwj/><emphasis>In situ</emphasis> ... is a Latin phrase that translates literally to &quot;on site&quot; or &quot;in position&quot;. It means &quot;locally&quot;, &quot;on site&quot;, &quot;on the premises&quot; or &quot;in place&quot; to describe an event where it takes place, and is used in many different contexts. ... (In computer science) An algorithm is said to be an in situ algorithm, or in-place algorithm, if the extra amount of memory required to execute the algorithm is O(1), that is, does not exceed a constant no matter how large the input. For example, heapsort is an in situ sorting algorithm. </para>
</blockquote>In normal parsing process, a large overhead is to decode JSON strings and copy them to other buffers. <emphasis>In situ</emphasis> parsing decodes those JSON string at the place where it is stored. It is possible in JSON because the length of decoded string is always shorter than or equal to the one in JSON. In this context, decoding a JSON string means to process the escapes, such as <computeroutput>&quot;\n&quot;</computeroutput>, <computeroutput>&quot;\u1234&quot;</computeroutput>, etc., and add a null terminator (<lsquo/><rsquo/>\0&apos;`)at the end of string.</para>
<para>The following diagrams compare normal and <emphasis>in situ</emphasis> parsing. The JSON string values contain pointers to the decoded string.</para>
<para><image type="html" name="diagram/normalparsing.png" alt="normal parsing" inline="yes"></image>
</para>
<para>In normal parsing, the decoded string are copied to freshly allocated buffers. <computeroutput>&quot;\\n&quot;</computeroutput> (2 characters) is decoded as <computeroutput>&quot;\n&quot;</computeroutput> (1 character). <computeroutput>&quot;\\u0073&quot;</computeroutput> (6 characters) is decoded as <computeroutput>&quot;s&quot;</computeroutput> (1 character).</para>
<para><image type="html" name="diagram/insituparsing.png" alt="instiu parsing" inline="yes"></image>
</para>
<para><emphasis>In situ</emphasis> parsing just modified the original JSON. Updated characters are highlighted in the diagram. If the JSON string does not contain escape character, such as <computeroutput>&quot;msg&quot;</computeroutput>, the parsing process merely replace the closing double quotation mark with a null character.</para>
<para>Since <emphasis>in situ</emphasis> parsing modify the input, the parsing API needs <computeroutput>char*</computeroutput> instead of <computeroutput>const char*</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Read<sp/>whole<sp/>file<sp/>into<sp/>a<sp/>buffer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>fp<sp/>=<sp/>fopen(</highlight><highlight class="stringliteral">&quot;test.json&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;r&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">fseek(fp,<sp/>0,<sp/>SEEK_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>filesize<sp/>=<sp/>(size_t)ftell(fp);</highlight></codeline>
<codeline><highlight class="normal">fseek(fp,<sp/>0,<sp/>SEEK_SET);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer<sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)malloc(filesize<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>readLength<sp/>=<sp/>fread(buffer,<sp/>1,<sp/>filesize,<sp/>fp);</highlight></codeline>
<codeline><highlight class="normal">buffer[readLength]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">fclose(fp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>In<sp/>situ<sp/>parsing<sp/>the<sp/>buffer<sp/>into<sp/>d,<sp/>buffer<sp/>will<sp/>also<sp/>be<sp/>modified</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">Document</ref><sp/>d;</highlight></codeline>
<codeline><highlight class="normal">d.<ref refid="class_generic_document_1a13f68b1896a24eea4cdbc03a3916225f" kindref="member">ParseInsitu</ref>(buffer);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Query/manipulate<sp/>the<sp/>DOM<sp/>here...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">free(buffer);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note:<sp/>At<sp/>this<sp/>point,<sp/>d<sp/>may<sp/>have<sp/>dangling<sp/>pointers<sp/>pointed<sp/>to<sp/>the<sp/>deallocated<sp/>buffer.</highlight></codeline>
</programlisting></para>
<para>The JSON strings are marked as const-string. But they may not be really &quot;constant&quot;. The life cycle of it depends on the JSON buffer.</para>
<para>In situ parsing minimizes allocation overheads and memory copying. Generally this improves cache coherence, which is an important factor of performance in modern computer.</para>
<para>There are some limitations of <emphasis>in situ</emphasis> parsing:</para>
<para><orderedlist>
<listitem><para>The whole JSON is in memory.</para>
</listitem><listitem><para>The source encoding in stream and target encoding in document must be the same.</para>
</listitem><listitem><para>The buffer need to be retained until the document is no longer used.</para>
</listitem><listitem><para>If the DOM need to be used for long period after parsing, and there are few JSON strings in the DOM, retaining the buffer may be a memory waste.</para>
</listitem></orderedlist>
</para>
<para><emphasis>In situ</emphasis> parsing is mostly suitable for short-term JSON that only need to be processed once, and then be released from memory. In practice, these situation is very common, for example, deserializing JSON to C++ objects, processing web requests represented in JSON, etc.</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_dom_zh_cn_1TranscodingAndValidation">
<title>Transcoding and Validation</title>
<para>RapidJSON supports conversion between Unicode formats (officially termed UCS Transformation Format) internally. During DOM parsing, the source encoding of the stream can be different from the encoding of the DOM. For example, the source stream contains a UTF-8 JSON, while the DOM is using UTF-16 encoding. There is an example code in <ref refid="stream_8md" kindref="compound">EncodedInputStream</ref>.</para>
<para>When writing a JSON from DOM to output stream, transcoding can also be used. An example is in <ref refid="stream_8md" kindref="compound">EncodedOutputStream</ref>.</para>
<para>During transcoding, the source string is decoded to into Unicode code points, and then the code points are encoded in the target format. During decoding, it will validate the byte sequence in the source string. If it is not a valid sequence, the parser will be stopped with <computeroutput>kParseErrorStringInvalidEncoding</computeroutput> error.</para>
<para>When the source encoding of stream is the same as encoding of DOM, by default, the parser will <emphasis>not</emphasis> validate the sequence. User may use <computeroutput>kParseValidateEncodingFlag</computeroutput> to force validation.</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_dom_zh_cn_1Techniques">
<title>Techniques</title>
<para>Some techniques about using DOM API is discussed here.</para>
<sect2 id="md_src_rapidjson_doc_dom_1autotoc_md44">
<title>DOM as SAX Event Publisher</title>
<para>In RapidJSON, stringifying a DOM with <computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput> may be look a little bit weird.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_writer" kindref="compound">Writer&lt;StringBuffer&gt;</ref><sp/>writer(buffer);</highlight></codeline>
<codeline><highlight class="normal">d.Accept(writer);</highlight></codeline>
</programlisting></para>
<para>Actually, <computeroutput>Value::Accept()</computeroutput> is responsible for publishing SAX events about the value to the handler. With this design, <computeroutput>Value</computeroutput> and <computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput> are decoupled. <computeroutput>Value</computeroutput> can generate SAX events, and <computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput> can handle those events.</para>
<para>User may create custom handlers for transforming the DOM into other formats. For example, a handler which converts the DOM into XML.</para>
<para>For more about SAX events and handler, please refer to <ref refid="sax_8md" kindref="compound">SAX</ref>.</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_dom_zh_cn_1UserBuffer">
<title>User Buffer</title>
<para>Some applications may try to avoid memory allocations whenever possible.</para>
<para><computeroutput><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator</ref></computeroutput> can support this by letting user to provide a buffer. The buffer can be on the program stack, or a &quot;scratch buffer&quot; which is statically allocated (a static/global array) for storing temporary data.</para>
<para><computeroutput><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator</ref></computeroutput> will use the user buffer to satisfy allocations. When the user buffer is used up, it will allocate a chunk of memory from the base allocator (by default the <computeroutput><ref refid="class_crt_allocator" kindref="compound">CrtAllocator</ref></computeroutput>).</para>
<para>Here is an example of using stack memory. The first allocator is for storing values, while the second allocator is for storing temporary data during parsing.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="class_generic_document" kindref="compound">GenericDocument&lt;UTF8&lt;&gt;</ref>,<sp/><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator&lt;&gt;</ref>,<sp/><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator&lt;&gt;</ref>&gt;<sp/>DocumentType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>valueBuffer[4096];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>parseBuffer[1024];</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator&lt;&gt;</ref><sp/>valueAllocator(valueBuffer,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(valueBuffer));</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator&lt;&gt;</ref><sp/>parseAllocator(parseBuffer,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(parseBuffer));</highlight></codeline>
<codeline><highlight class="normal">DocumentType<sp/>d(&amp;valueAllocator,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(parseBuffer),<sp/>&amp;parseAllocator);</highlight></codeline>
<codeline><highlight class="normal">d.<ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">Parse</ref>(json);</highlight></codeline>
</programlisting></para>
<para>If the total size of allocation is less than 4096+1024 bytes during parsing, this code does not invoke any heap allocation (via <computeroutput>new</computeroutput> or <computeroutput>malloc()</computeroutput>) at all.</para>
<para>User can query the current memory consumption in bytes via <computeroutput><ref refid="class_memory_pool_allocator_1a53abb6188aea4a687ca9f6d778fd1d2d" kindref="member">MemoryPoolAllocator::Size()</ref></computeroutput>. And then user can determine a suitable size of user buffer. </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="src/rapidjson/doc/dom.md"/>
  </compounddef>
</doxygen>
