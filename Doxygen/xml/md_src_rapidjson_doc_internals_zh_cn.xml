<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="md_src_rapidjson_doc_internals_zh_cn" kind="page">
    <compoundname>md_src_rapidjson_doc_internals_zh_cn</compoundname>
    <title>内部架构</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>本部分记录了一些设计和实现细节。</para>
<sect1 id="md_src_rapidjson_doc_internals_zh_cn_1Architecture">
<title>Architecture</title>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1autotoc_md96">
<title>SAX 和 DOM</title>
<para>下面的 UML 图显示了 SAX 和 DOM 的基本关系。</para>
<para><image type="html" name="diagram/architecture.png" alt="架构 UML 类图" inline="yes"></image>
</para>
<para>关系的核心是 <computeroutput>Handler</computeroutput> 概念。在 SAX 一边，<computeroutput>Reader</computeroutput> 从流解析 JSON 并将事件发送到 <computeroutput>Handler</computeroutput>。<computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput> 实现了 <computeroutput>Handler</computeroutput> 概念，用于处理相同的事件。在 DOM 一边，<computeroutput>Document</computeroutput> 实现了 <computeroutput>Handler</computeroutput> 概念，用于通过这些时间来构建 DOM。<computeroutput>Value</computeroutput> 支持了 <computeroutput>Value::Accept(Handler&amp;)</computeroutput> 函数，它可以将 DOM 转换为事件进行发送。</para>
<para>在这个设计，SAX 是不依赖于 DOM 的。甚至 <computeroutput>Reader</computeroutput> 和 <computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput> 之间也没有依赖。这提供了连接事件发送器和处理器的灵活性。除此之外，<computeroutput>Value</computeroutput> 也是不依赖于 SAX 的。所以，除了将 DOM 序列化为 JSON 之外，用户也可以将其序列化为 XML，或者做任何其他事情。</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1autotoc_md97">
<title>工具类</title>
<para>SAX 和 DOM API 都依赖于3个额外的概念：<computeroutput>Allocator</computeroutput>、<computeroutput>Encoding</computeroutput> 和 <computeroutput>Stream</computeroutput>。它们的继承层次结构如下图所示。</para>
<para><image type="html" name="diagram/utilityclass.png" alt="工具类 UML 类图" inline="yes"></image>
</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_internals_zh_cn_1Value">
<title>Value</title>
<para><computeroutput>Value</computeroutput> （实际上被定义为 <computeroutput><ref refid="class_generic_value" kindref="compound">GenericValue</ref>&lt;<ref refid="struct_u_t_f8" kindref="compound">UTF8</ref>&lt;&gt;&gt;</computeroutput>）是 DOM API 的核心。本部分描述了它的设计。</para>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1DataLayout">
<title>Data Layout</title>
<para><computeroutput>Value</computeroutput> 是<ulink url="http://en.wikipedia.org/wiki/Variant_type">可变类型</ulink>。在 RapidJSON 的上下文中，一个 <computeroutput>Value</computeroutput> 的实例可以包含6种 JSON 数据类型之一。通过使用 <computeroutput>union</computeroutput> ，这是可能实现的。每一个 <computeroutput>Value</computeroutput> 包含两个成员：<computeroutput>union Data data_</computeroutput> 和 <computeroutput>unsigned flags_</computeroutput>。<computeroutput>flags_</computeroutput> 表明了 JSON 类型，以及附加的信息。</para>
<para>下表显示了所有类型的数据布局。32位/64位列表明了字段所占用的字节数。</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>Null   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kNullType kNullFlag</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>Bool   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kBoolType</computeroutput> (either <computeroutput>kTrueFlag</computeroutput> or <computeroutput>kFalseFlag</computeroutput>)   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>String   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>Ch* str</computeroutput>   </para>
</entry><entry thead="no"><para>指向字符串的指针（可能拥有所有权）   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>SizeType length</computeroutput>   </para>
</entry><entry thead="no"><para>字符串长度   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kStringType kStringFlag ...</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>Object   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>Member* members</computeroutput>   </para>
</entry><entry thead="no"><para>指向成员数组的指针（拥有所有权）   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>SizeType size</computeroutput>   </para>
</entry><entry thead="no"><para>成员数量   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>SizeType capacity</computeroutput>   </para>
</entry><entry thead="no"><para>成员容量   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kObjectType kObjectFlag</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>Array   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>Value* values</computeroutput>   </para>
</entry><entry thead="no"><para>指向值数组的指针（拥有所有权）   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>SizeType size</computeroutput>   </para>
</entry><entry thead="no"><para>值数量   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>SizeType capacity</computeroutput>   </para>
</entry><entry thead="no"><para>值容量   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kArrayType kArrayFlag</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>Number (Int)   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>int i</computeroutput>   </para>
</entry><entry thead="no"><para>32位有符号整数   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（零填充）   </para>
</entry><entry thead="no"><para>0   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kNumberType kNumberFlag kIntFlag kInt64Flag ...</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes"><para>Number (UInt)   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned u</computeroutput>   </para>
</entry><entry thead="no"><para>32位无符号整数   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（零填充）   </para>
</entry><entry thead="no"><para>0   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kNumberType kNumberFlag kUintFlag kUint64Flag ...</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="4" cols="4"><row>
<entry thead="yes"><para>Number (Int64)   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>int64_t i64</computeroutput>   </para>
</entry><entry thead="no"><para>64位有符号整数   </para>
</entry><entry thead="no" align='center'><para>8   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kNumberType kNumberFlag kInt64Flag ...</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="4" cols="4"><row>
<entry thead="yes"><para>Number (Uint64)   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>uint64_t i64</computeroutput>   </para>
</entry><entry thead="no"><para>64位无符号整数   </para>
</entry><entry thead="no" align='center'><para>8   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kNumberType kNumberFlag kInt64Flag ...</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para><table rows="4" cols="4"><row>
<entry thead="yes"><para>Number (Double)   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>uint64_t i64</computeroutput>   </para>
</entry><entry thead="no"><para>双精度浮点数   </para>
</entry><entry thead="no" align='center'><para>8   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para>（未使用）   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>8    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kNumberType kNumberFlag kDoubleFlag</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para>这里有一些需要注意的地方：<itemizedlist>
<listitem><para>为了减少在64位架构上的内存消耗，<computeroutput>SizeType</computeroutput> 被定义为 <computeroutput>unsigned</computeroutput> 而不是 <computeroutput>size_t</computeroutput>。</para>
</listitem><listitem><para>32位整数的零填充可能被放在实际类型的前面或后面，这依赖于字节序。这使得它可以将32位整数不经过任何转换就可以解释为64位整数。</para>
</listitem><listitem><para><computeroutput>Int</computeroutput> 永远是 <computeroutput>Int64</computeroutput>，反之不然。</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1Flags">
<title>Flags</title>
<para>32位的 <computeroutput>flags_</computeroutput> 包含了 JSON 类型和其他信息。如前文中的表所述，每一种 JSON 类型包含了冗余的 <computeroutput>kXXXType</computeroutput> 和 <computeroutput>kXXXFlag</computeroutput>。这个设计是为了优化测试位标志（<computeroutput>IsNumber()</computeroutput>）和获取每一种类型的序列号（<computeroutput>GetType()</computeroutput>）。</para>
<para>字符串有两个可选的标志。<computeroutput>kCopyFlag</computeroutput> 表明这个字符串拥有字符串拷贝的所有权。而 <computeroutput>kInlineStrFlag</computeroutput> 意味着使用了<ref refid="md_src_rapidjson_doc_internals_zh_cn_1ShortString" kindref="member">短字符串优化</ref>。</para>
<para>数字更加复杂一些。对于普通的整数值，它可以包含 <computeroutput>kIntFlag</computeroutput>、<computeroutput>kUintFlag</computeroutput>、 <computeroutput>kInt64Flag</computeroutput> 和/或 <computeroutput>kUint64Flag</computeroutput>，这由整数的范围决定。带有小数或者超过64位所能表达的范围的整数的数字会被存储为带有 <computeroutput>kDoubleFlag</computeroutput> 的 <computeroutput>double</computeroutput>。</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1ShortString">
<title>Short-String Optimization</title>
<para><ulink url="https://github.com/Kosta-Github">Kosta</ulink> 提供了很棒的短字符串优化。这个优化的xxx如下所述。除去 <computeroutput>flags_</computeroutput> ，<computeroutput>Value</computeroutput> 有12或16字节（对于32位或64位）来存储实际的数据。这为在其内部直接存储短字符串而不是存储字符串的指针创造了可能。对于1字节的字符类型（例如 <computeroutput>char</computeroutput>），它可以在 <computeroutput>Value</computeroutput> 类型内部存储至多11或15个字符的字符串。</para>
<para><table rows="4" cols="4"><row>
<entry thead="yes"><para>ShortString (Ch=char)   </para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes" align='center'><para>32位   </para>
</entry><entry thead="yes" align='center'><para>64位    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>Ch str[MaxChars]</computeroutput>   </para>
</entry><entry thead="no"><para>字符串缓冲区   </para>
</entry><entry thead="no" align='center'><para>11   </para>
</entry><entry thead="no" align='center'><para>15    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>Ch invLength</computeroutput>   </para>
</entry><entry thead="no"><para>MaxChars - Length   </para>
</entry><entry thead="no" align='center'><para>1   </para>
</entry><entry thead="no" align='center'><para>1    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>unsigned flags_</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>kStringType kStringFlag ...</computeroutput>   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry><entry thead="no" align='center'><para>4   </para>
</entry></row>
</table>
</para>
<para>这里使用了一项特殊的技术。它存储了 (MaxChars - length) 而不直接存储字符串的长度。这使得存储11个字符并且带有后缀 <computeroutput>\0</computeroutput> 成为可能。</para>
<para>这个优化可以减少字符串拷贝内存占用。它也改善了缓存一致性，并进一步提高了运行时性能。</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_internals_zh_cn_1InternalAllocator">
<title>Allocator</title>
<para><computeroutput>Allocator</computeroutput> 是 RapidJSON 中的概念： <programlisting filename=".cpp"><codeline><highlight class="keyword">concept<sp/></highlight><highlight class="normal"><ref refid="classrapidjson_1_1_allocator" kindref="compound">Allocator</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>const<sp/>bool<sp/>kNeedFree;<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>申请内存块。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>\param<sp/>size<sp/>内存块的大小，以字节记。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>\returns<sp/>指向内存块的指针。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void*<sp/><ref refid="allocators_8h_1a7e0ace0214f18427d9ee8e76a5b3dcdf" kindref="member">Malloc</ref>(size_t<sp/>size);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>调整内存块的大小。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>\param<sp/>originalPtr<sp/>当前内存块的指针。空指针是被允许的。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>\param<sp/>originalSize<sp/>当前大小，以字节记。（设计问题：因为有些分配器可能不会记录它，显示的传递它可以节约内存。）</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>\param<sp/>newSize<sp/>新大小，以字节记。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void*<sp/><ref refid="allocators_8h_1a8e4137cbc097868e8c3d785f6cca1223" kindref="member">Realloc</ref>(void*<sp/>originalPtr,<sp/>size_t<sp/>originalSize,<sp/>size_t<sp/>newSize);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>释放内存块。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>\param<sp/>ptr<sp/>指向内存块的指针。空指针是被允许的。</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>void<sp/><ref refid="allocators_8h_1a471c182d62d396b7d5d564e8d6a62d9e" kindref="member">Free</ref>(void<sp/>*ptr);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>需要注意的是 <computeroutput><ref refid="allocators_8h_1a7e0ace0214f18427d9ee8e76a5b3dcdf" kindref="member">Malloc()</ref></computeroutput> 和 <computeroutput><ref refid="allocators_8h_1a8e4137cbc097868e8c3d785f6cca1223" kindref="member">Realloc()</ref></computeroutput> 是成员函数而 <computeroutput><ref refid="allocators_8h_1a471c182d62d396b7d5d564e8d6a62d9e" kindref="member">Free()</ref></computeroutput> 是静态成员函数。</para>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1MemoryPoolAllocator">
<title>MemoryPoolAllocator</title>
<para><computeroutput><ref refid="class_memory_pool_allocator" kindref="compound">MemoryPoolAllocator</ref></computeroutput> 是 DOM 的默认内存分配器。它只申请内存而不释放内存。这对于构建 DOM 树非常合适。</para>
<para>在它的内部，它从基础的内存分配器申请内存块（默认为 <computeroutput><ref refid="class_crt_allocator" kindref="compound">CrtAllocator</ref></computeroutput>）并将这些内存块存储为单向链表。当用户请求申请内存，它会遵循下列步骤来申请内存：</para>
<para><orderedlist>
<listitem><para>如果可用，使用用户提供的缓冲区。（见 <ref refid="dom_8md" kindref="compound">User Buffer section in DOM</ref>）</para>
</listitem><listitem><para>如果用户提供的缓冲区已满，使用当前内存块。</para>
</listitem><listitem><para>如果当前内存块已满，申请新的内存块。</para>
</listitem></orderedlist>
</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_internals_zh_cn_1ParsingOptimization">
<title>Parsing Optimization</title>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1SkipwhitespaceWithSIMD">
<title>Skip Whitespaces with SIMD</title>
<para>当从流中解析 JSON 时，解析器需要跳过4种空格字符：</para>
<para><orderedlist>
<listitem><para>空格 (<computeroutput>U+0020</computeroutput>)</para>
</listitem><listitem><para>制表符 (<computeroutput>U+000B</computeroutput>)</para>
</listitem><listitem><para>换行 (<computeroutput>U+000A</computeroutput>)</para>
</listitem><listitem><para>回车 (<computeroutput>U+000D</computeroutput>)</para>
</listitem></orderedlist>
</para>
<para>这是一份简单的实现： <programlisting filename=".cpp"><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="reader_8h_1a60338858b2582eca23f3e509a2d82e0e" kindref="member">SkipWhitespace</ref>(InputStream&amp;<sp/>s)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>||<sp/>s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal"><sp/>||<sp/>s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\r&apos;</highlight><highlight class="normal"><sp/>||<sp/>s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\t&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s.Take();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>但是，这需要对每个字符进行4次比较以及一些分支。这被发现是一个热点。</para>
<para>为了加速这一处理，RapidJSON 使用 SIMD 来在一次迭代中比较16个字符和4个空格。目前 RapidJSON 支持 SSE2 ， SSE4.2 和 ARM Neon 指令。同时它也只会对 UTF-8 内存流启用，包括字符串流或 <emphasis>原位</emphasis> 解析。</para>
<para>你可以通过在包含 <computeroutput><ref refid="rapidjson_8h" kindref="compound">rapidjson.h</ref></computeroutput> 之前定义 <computeroutput>RAPIDJSON_SSE2</computeroutput> ， <computeroutput>RAPIDJSON_SSE42</computeroutput> 或 <computeroutput>RAPIDJSON_NEON</computeroutput> 来启用这个优化。一些编译器可以检测这个设置，如 <computeroutput><ref refid="perftest_8h" kindref="compound">perftest.h</ref></computeroutput>：</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>__SSE2__<sp/>和<sp/>__SSE4_2__<sp/>可被<sp/>gcc、clang<sp/>和<sp/>Intel<sp/>编译器识别：</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>如果支持的话，我们在<sp/>gmake<sp/>中使用了<sp/>-march=native<sp/>来启用<sp/>-msse2<sp/>和<sp/>-msse4.2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>同样的，<sp/>__ARM_NEON<sp/>被用于识别Neon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__SSE4_2__)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>define<sp/>RAPIDJSON_SSE42</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined(__SSE2__)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>define<sp/>RAPIDJSON_SSE2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined(__ARM_NEON)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>define<sp/>RAPIDJSON_NEON</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
<para>需要注意的是，这是编译期的设置。在不支持这些指令的机器上运行可执行文件会使它崩溃。</para>
<sect3 id="md_src_rapidjson_doc_internals_zh_cn_1autotoc_md98">
<title>页面对齐问题</title>
<para>在 RapidJSON 的早期版本中，被报告了<ulink url="https://code.google.com/archive/p/rapidjson/issues/104">一个问题</ulink>：<computeroutput>SkipWhitespace_SIMD()</computeroutput> 会罕见地导致崩溃（约五十万分之一的几率）。在调查之后，怀疑是 <computeroutput>_mm_loadu_si128()</computeroutput> 访问了 <lsquo/><rsquo/>\0&apos;` 之后的内存，并越过被保护的页面边界。</para>
<para>在 <ulink url="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html">Intel® 64 and IA-32 Architectures Optimization Reference Manual</ulink> 中，章节 10.2.1：</para>
<para><blockquote><para><zwj/>为了支持需要费对齐的128位 SIMD 内存访问的算法，调用者的内存缓冲区申请应当考虑添加一些填充空间，这样被调用的函数可以安全地将地址指针用于未对齐的128位 SIMD 内存操作。 在结合非对齐的 SIMD 内存操作中，最小的对齐大小应该等于 SIMD 寄存器的大小。 </para>
</blockquote>对于 RapidJSON 来说，这显然是不可行的，因为 RapidJSON 不应当强迫用户进行内存对齐。</para>
<para>为了修复这个问题，当前的代码会先按字节处理直到下一个对齐的地址。在这之后，使用对齐读取来进行 SIMD 处理。见 <ulink url="https://github.com/Tencent/rapidjson/issues/85">#85</ulink>。</para>
</sect3>
</sect2>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1LocalStreamCopy">
<title>Local Stream Copy</title>
<para>在优化的过程中，我们发现一些编译器不能将访问流的一些成员数据放入局部变量或者寄存器中。测试结果显示，对于一些流类型，创建流的拷贝并将其用于内层循环中可以改善性能。例如，实际（非 SIMD）的 <computeroutput><ref refid="reader_8h_1a60338858b2582eca23f3e509a2d82e0e" kindref="member">SkipWhitespace()</ref></computeroutput> 被实现为：</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>InputStream&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="reader_8h_1a60338858b2582eca23f3e509a2d82e0e" kindref="member">SkipWhitespace</ref>(InputStream&amp;<sp/>is)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classinternal_1_1_stream_local_copy" kindref="compound">internal::StreamLocalCopy&lt;InputStream&gt;</ref><sp/>copy(is);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InputStream&amp;<sp/>s(copy.s);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>||<sp/>s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal"><sp/>||<sp/>s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\r&apos;</highlight><highlight class="normal"><sp/>||<sp/>s.Peek()<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\t&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s.Take();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>基于流的特征，<computeroutput>StreamLocalCopy</computeroutput> 会创建（或不创建）流对象的拷贝，在局部使用它并将流的状态拷贝回原来的流。</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1ParsingDouble">
<title>Parsing to Double</title>
<para>将字符串解析为 <computeroutput>double</computeroutput> 并不简单。标准库函数 <computeroutput>strtod()</computeroutput> 可以胜任这项工作，但它比较缓慢。默认情况下，解析器使用默认的精度设置。这最多有 3<ulink url="http://en.wikipedia.org/wiki/Unit_in_the_last_place">ULP</ulink> 的误差，并实现在 <computeroutput><ref refid="namespaceinternal_1a9e5fac4695310f09892fe52b1d24ab19" kindref="member">internal::StrtodNormalPrecision()</ref></computeroutput> 中。</para>
<para>当使用 <computeroutput>kParseFullPrecisionFlag</computeroutput> 时，编译器会改为调用 <computeroutput><ref refid="namespaceinternal_1a6109c750ee4707d4f71de280816a1a00" kindref="member">internal::StrtodFullPrecision()</ref></computeroutput> ，这个函数会自动调用三个版本的转换。<orderedlist>
<listitem><para><ulink url="http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion/">Fast-Path</ulink>。</para>
</listitem><listitem><para><ulink url="https://github.com/floitsch/double-conversion">double-conversion</ulink> 中的自定义 DIY-FP 实现。</para>
</listitem><listitem><para>（Clinger, William D. How to read floating point numbers accurately. Vol. 25. No. 6. ACM, 1990） 中的大整数算法。</para>
</listitem></orderedlist>
</para>
<para>如果第一个转换方法失败，则尝试使用第二种方法，以此类推。</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_internals_zh_cn_1GenerationOptimization">
<title>Generation Optimization</title>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1itoa">
<title>Integer-to-String conversion</title>
<para>整数到字符串转换的朴素算法需要对每一个十进制位进行一次除法。我们实现了若干版本并在 <ulink url="https://github.com/miloyip/itoa-benchmark">itoa-benchmark</ulink> 中对它们进行了评估。</para>
<para>虽然 SSE2 版本是最快的，但它和第二快的 <computeroutput>branchlut</computeroutput> 差距不大。而且 <computeroutput>branchlut</computeroutput> 是纯C++实现，所以我们在 RapidJSON 中使用了 <computeroutput>branchlut</computeroutput>。</para>
</sect2>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1dtoa">
<title>Double-to-String conversion</title>
<para>原来 RapidJSON 使用 <computeroutput>snprintf(..., ..., &quot;%g&quot;)</computeroutput> 来进行双精度浮点数到字符串的转换。这是不准确的，因为默认的精度是6。随后我们发现它很缓慢，而且有其它的替代品。</para>
<para>Google 的 V8 <ulink url="https://github.com/floitsch/double-conversion">double-conversion</ulink> 实现了更新的、快速的被称为 Grisu3 的算法（Loitsch, Florian. &quot;Printing floating-point numbers quickly and accurately with integers.&quot; ACM Sigplan Notices 45.6 (2010): 233-243.）。</para>
<para>然而，这个实现不是仅头文件的，所以我们实现了一个仅头文件的 Grisu2 版本。这个算法保证了结果永远精确。而且在大多数情况下，它会生成最短的（可选）字符串表示。</para>
<para>这个仅头文件的转换函数在 <ulink url="https://github.com/miloyip/dtoa-benchmark">dtoa-benchmark</ulink> 中进行评估。</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_internals_zh_cn_1Parser">
<title>Parser</title>
<sect2 id="md_src_rapidjson_doc_internals_zh_cn_1IterativeParser">
<title>Iterative Parser</title>
<para>迭代解析器是一个以非递归方式实现的递归下降的 LL(1) 解析器。</para>
<sect3 id="md_src_rapidjson_doc_internals_zh_cn_1IterativeParserGrammar">
<title>Grammar</title>
<para>解析器使用的语法是基于严格 JSON 语法的： <programlisting><codeline><highlight class="normal">S<sp/>-&gt;<sp/>array<sp/>|<sp/>object</highlight></codeline>
<codeline><highlight class="normal">array<sp/>-&gt;<sp/>[<sp/>values<sp/>]</highlight></codeline>
<codeline><highlight class="normal">object<sp/>-&gt;<sp/>{<sp/>members<sp/>}</highlight></codeline>
<codeline><highlight class="normal">values<sp/>-&gt;<sp/>non-empty-values<sp/>|<sp/>ε</highlight></codeline>
<codeline><highlight class="normal">non-empty-values<sp/>-&gt;<sp/>value<sp/>addition-values</highlight></codeline>
<codeline><highlight class="normal">addition-values<sp/>-&gt;<sp/>ε<sp/>|<sp/>,<sp/>non-empty-values</highlight></codeline>
<codeline><highlight class="normal">members<sp/>-&gt;<sp/>non-empty-members<sp/>|<sp/>ε</highlight></codeline>
<codeline><highlight class="normal">non-empty-members<sp/>-&gt;<sp/>member<sp/>addition-members</highlight></codeline>
<codeline><highlight class="normal">addition-members<sp/>-&gt;<sp/>ε<sp/>|<sp/>,<sp/>non-empty-members</highlight></codeline>
<codeline><highlight class="normal">member<sp/>-&gt;<sp/>STRING<sp/>:<sp/>value</highlight></codeline>
<codeline><highlight class="normal">value<sp/>-&gt;<sp/>STRING<sp/>|<sp/>NUMBER<sp/>|<sp/>NULL<sp/>|<sp/>BOOLEAN<sp/>|<sp/>object<sp/>|<sp/>array</highlight></codeline>
</programlisting></para>
<para>注意到左因子被加入了非终结符的 <computeroutput>values</computeroutput> 和 <computeroutput>members</computeroutput> 来保证语法是 LL(1) 的。</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_internals_zh_cn_1IterativeParserParsingTable">
<title>Parsing Table</title>
<para>基于这份语法，我们可以构造 FIRST 和 FOLLOW 集合。</para>
<para>非终结符的 FIRST 集合如下所示：</para>
<para><table rows="12" cols="2"><row>
<entry thead="yes" align='center'><para>NON-TERMINAL   </para>
</entry><entry thead="yes" align='center'><para>FIRST    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>array   </para>
</entry><entry thead="no" align='center'><para>[    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>object   </para>
</entry><entry thead="no" align='center'><para>{    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>values   </para>
</entry><entry thead="no" align='center'><para>ε STRING NUMBER NULL BOOLEAN { [    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>addition-values   </para>
</entry><entry thead="no" align='center'><para>ε COMMA    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>members   </para>
</entry><entry thead="no" align='center'><para>ε STRING    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>addition-members   </para>
</entry><entry thead="no" align='center'><para>ε COMMA    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>member   </para>
</entry><entry thead="no" align='center'><para>STRING    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>value   </para>
</entry><entry thead="no" align='center'><para>STRING NUMBER NULL BOOLEAN { [    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>S   </para>
</entry><entry thead="no" align='center'><para>[ {    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>non-empty-members   </para>
</entry><entry thead="no" align='center'><para>STRING    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>STRING NUMBER NULL BOOLEAN { [   </para>
</entry></row>
</table>
</para>
<para>FOLLOW 集合如下所示：</para>
<para><table rows="12" cols="2"><row>
<entry thead="yes" align='center'><para>NON-TERMINAL   </para>
</entry><entry thead="yes" align='center'><para>FOLLOW    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>S   </para>
</entry><entry thead="no" align='center'><para>$    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>array   </para>
</entry><entry thead="no" align='center'><para>, $ } ]    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>object   </para>
</entry><entry thead="no" align='center'><para>, $ } ]    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>values   </para>
</entry><entry thead="no" align='center'><para>]    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>]    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>addition-values   </para>
</entry><entry thead="no" align='center'><para>]    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>members   </para>
</entry><entry thead="no" align='center'><para>}    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>non-empty-members   </para>
</entry><entry thead="no" align='center'><para>}    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>addition-members   </para>
</entry><entry thead="no" align='center'><para>}    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>member   </para>
</entry><entry thead="no" align='center'><para>, }    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>value   </para>
</entry><entry thead="no" align='center'><para>, } ]   </para>
</entry></row>
</table>
</para>
<para>最终可以从 FIRST 和 FOLLOW 集合生成解析表：</para>
<para><table rows="12" cols="11"><row>
<entry thead="yes" align='center'><para>NON-TERMINAL   </para>
</entry><entry thead="yes" align='center'><para>[   </para>
</entry><entry thead="yes" align='center'><para>{   </para>
</entry><entry thead="yes" align='center'><para>,   </para>
</entry><entry thead="yes" align='center'><para>:   </para>
</entry><entry thead="yes" align='center'><para>]   </para>
</entry><entry thead="yes" align='center'><para>}   </para>
</entry><entry thead="yes" align='center'><para>STRING   </para>
</entry><entry thead="yes" align='center'><para>NUMBER   </para>
</entry><entry thead="yes" align='center'><para>NULL   </para>
</entry><entry thead="yes" align='center'><para>BOOLEAN    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>S   </para>
</entry><entry thead="no" align='center'><para>array   </para>
</entry><entry thead="no" align='center'><para>object   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>array   </para>
</entry><entry thead="no" align='center'><para>[ values ]   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>object   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>{ members }   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>values   </para>
</entry><entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>ε   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>non-empty-values    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>non-empty-values   </para>
</entry><entry thead="no" align='center'><para>value addition-values   </para>
</entry><entry thead="no" align='center'><para>value addition-values   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>value addition-values   </para>
</entry><entry thead="no" align='center'><para>value addition-values   </para>
</entry><entry thead="no" align='center'><para>value addition-values   </para>
</entry><entry thead="no" align='center'><para>value addition-values    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>addition-values   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>, non-empty-values   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>ε   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>members   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>ε   </para>
</entry><entry thead="no" align='center'><para>non-empty-members   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>non-empty-members   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>member addition-members   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>addition-members   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>, non-empty-members   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>ε   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>member   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>STRING : value   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry></row>
<row>
<entry thead="no" align='center'><para>value   </para>
</entry><entry thead="no" align='center'><para>array   </para>
</entry><entry thead="no" align='center'><para>object   </para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para></para>
</entry><entry thead="no" align='center'><para>STRING   </para>
</entry><entry thead="no" align='center'><para>NUMBER   </para>
</entry><entry thead="no" align='center'><para>NULL   </para>
</entry><entry thead="no" align='center'><para>BOOLEAN   </para>
</entry></row>
</table>
</para>
<para>对于上面的语法分析，这里有一个很棒的<ulink url="http://hackingoff.com/compilers/predict-first-follow-set">工具</ulink>。</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_internals_zh_cn_1IterativeParserImplementation">
<title>Implementation</title>
<para>基于这份解析表，一个直接的（常规的）将规则反向入栈的实现可以正常工作。</para>
<para>在 RapidJSON 中，对直接的实现进行了一些修改：</para>
<para>首先，在 RapidJSON 中，这份解析表被编码为状态机。 规则由头部和主体组成。 状态转换由规则构造。 除此之外，额外的状态被添加到与 <computeroutput>array</computeroutput> 和 <computeroutput>object</computeroutput> 有关的规则。 通过这种方式，生成数组值或对象成员可以只用一次状态转移便可完成， 而不需要在直接的实现中的多次出栈/入栈操作。 这也使得估计栈的大小更加容易。</para>
<para>状态图如如下所示：</para>
<para><image type="html" name="diagram/iterative-parser-states-diagram.png" alt="状态图" inline="yes"></image>
</para>
<para>第二，迭代解析器也在内部栈保存了数组的值个数和对象成员的数量，这也与传统的实现不同。 </para>
</sect3>
</sect2>
</sect1>
    </detaileddescription>
    <location file="src/rapidjson/doc/internals.zh-cn.md"/>
  </compounddef>
</doxygen>
