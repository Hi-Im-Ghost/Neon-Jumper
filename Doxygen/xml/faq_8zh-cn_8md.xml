<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="faq_8zh-cn_8md" kind="file" language="Markdown">
    <compoundname>faq.zh-cn.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#<sp/>常见问题</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">[TOC]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>一般问题</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>RapidJSON<sp/>是什么？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>是一个<sp/>C++<sp/>库，用于解析及生成<sp/>JSON。读者可参考它的所有<sp/>[特点](doc/features.zh-cn.md)。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>为什么称作<sp/>RapidJSON？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>它的灵感来自于<sp/>[RapidXML](http://rapidxml.sourceforge.net/)，RapidXML<sp/>是一个高速的<sp/>XML<sp/>DOM<sp/>解析器。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>RapidJSON<sp/>与<sp/>RapidXML<sp/>相似么？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>借镜了<sp/>RapidXML<sp/>的一些设计,<sp/>包括原位（*in<sp/>situ*）解析、只有头文件的库。但两者的<sp/>API<sp/>是完全不同的。此外<sp/>RapidJSON<sp/>也提供许多<sp/>RapidXML<sp/>没有的特点。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>RapidJSON<sp/>是免费的么？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>是的，它在<sp/>MIT<sp/>协议下免费。它可用于商业软件。详情请参看<sp/>[license.txt](https://github.com/Tencent/rapidjson/blob/master/license.txt)。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">5.<sp/>RapidJSON<sp/>很小么？它有何依赖？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>是的。在<sp/>Windows<sp/>上，一个解析<sp/>JSON<sp/>并打印出统计的可执行文件少于<sp/>30KB。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>仅依赖于<sp/>C++<sp/>标准库。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">6.<sp/>怎样安装<sp/>RapidJSON？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>见<sp/>[安装一节](../readme.zh-cn.md#安装)。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">7.<sp/>RapidJSON<sp/>能否运行于我的平台？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>社区已在多个操作系统／编译器／CPU<sp/>架构的组合上测试<sp/>RapidJSON。但我们无法确保它能运行于你特定的平台上。只需要生成及执行单元测试便能获取答案。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">8.<sp/>RapidJSON<sp/>支持<sp/>C++03<sp/>么？C++11<sp/>呢？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>开始时在<sp/>C++03<sp/>上实现。后来加入了可选的<sp/>C++11<sp/>特性支持（如转移构造函数、`noexcept`）。RapidJSON<sp/>应该兼容所有遵从<sp/>C++03<sp/>或<sp/>C++11<sp/>的编译器。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">9.<sp/>RapidJSON<sp/>是否真的用于实际应用？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>是的。它被配置于前台及后台的真实应用中。一个社区成员说<sp/>RapidJSON<sp/>在他们的系统中每日解析<sp/>5<sp/>千万个<sp/>JSON。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">10.<sp/>RapidJSON<sp/>是如何被测试的？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>包含一组单元测试去执行自动测试。[Travis](https://travis-ci.org/Tencent/rapidjson/)（供<sp/>Linux<sp/>平台）及<sp/>[AppVeyor](https://ci.appveyor.com/project/Tencent/rapidjson/)（供<sp/>Windows<sp/>平台）会对所有修改进行编译及执行单元测试。在<sp/>Linux<sp/>下还会使用<sp/>Valgrind<sp/>去检测内存泄漏。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">11.<sp/>RapidJSON<sp/>是否有完整的文档？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>提供了使用手册及<sp/>API<sp/>说明文档。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">12.<sp/>有没有其他替代品？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>有许多替代品。例如<sp/>[nativejson-benchmark](https://github.com/miloyip/nativejson-benchmark)<sp/>列出了一些开源的<sp/>C/C++<sp/>JSON<sp/>库。[json.org](http://www.json.org/)<sp/>也有一个列表。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>JSON</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>什么是<sp/>JSON？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>JSON<sp/>(JavaScript<sp/>Object<sp/>Notation)<sp/>是一个轻量的数据交换格式。它使用人类可读的文本格式。更多关于<sp/>JSON<sp/>的细节可考<sp/>[RFC7159](http://www.ietf.org/rfc/rfc7159.txt)<sp/>及<sp/>[ECMA-404](http://www.ecma-international.org/publications/standards/Ecma-404.htm)。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>JSON<sp/>有什么应用场合？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>JSON<sp/>常用于网页应用程序，以传送结构化数据。它也可作为文件格式用于数据持久化。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>RapidJSON<sp/>是否符合<sp/>JSON<sp/>标准？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>是。RapidJSON<sp/>完全符合<sp/>[RFC7159](http://www.ietf.org/rfc/rfc7159.txt)<sp/>及<sp/>[ECMA-404](http://www.ecma-international.org/publications/standards/Ecma-404.htm)。它能处理一些特殊情况，例如支持<sp/>JSON<sp/>字符串中含有空字符及代理对（surrogate<sp/>pair）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>RapidJSON<sp/>是否支持宽松的语法？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>目前不支持。RapidJSON<sp/>只支持严格的标准格式。宽松语法可以在这个<sp/>[issue](https://github.com/Tencent/rapidjson/issues/36)<sp/>中进行讨论。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>DOM<sp/>与<sp/>SAX</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>什么是<sp/>DOM<sp/>风格<sp/>API？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Document<sp/>Object<sp/>Model（DOM）是一个储存于内存的<sp/>JSON<sp/>表示方式，用于查询及修改<sp/>JSON。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>什么是<sp/>SAX<sp/>风格<sp/>API?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>SAX<sp/>是一个事件驱动的<sp/>API，用于解析及生成<sp/>JSON。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>我应用<sp/>DOM<sp/>还是<sp/>SAX？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>DOM<sp/>易于查询及修改。SAX<sp/>则是非常快及省内存的，但通常较难使用。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>什么是原位（*in<sp/>situ*）解析？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>原位解析会把<sp/>JSON<sp/>字符串直接解码至输入的<sp/>JSON<sp/>中。这是一个优化，可减少内存消耗及提升性能，但输入的<sp/>JSON<sp/>会被更改。进一步细节请参考<sp/>[原位解析](doc/dom.zh-cn.md)<sp/>。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">5.<sp/>什么时候会产生解析错误？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>当输入的<sp/>JSON<sp/>包含非法语法，或不能表示一个值（如<sp/>Number<sp/>太大），或解析器的处理器中断解析过程，解析器都会产生一个错误。详情请参考<sp/>[解析错误](doc/dom.zh-cn.md)。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">6.<sp/>有什么错误信息？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>错误信息存储在<sp/>`ParseResult`，它包含错误代号及偏移值（从<sp/>JSON<sp/>开始至错误处的字符数目）。可以把错误代号翻译为人类可读的错误讯息。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">7.<sp/>为何不只使用<sp/>`double`<sp/>去表示<sp/>JSON<sp/>number？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>一些应用需要使用<sp/>64<sp/>位无号／有号整数。这些整数不能无损地转换成<sp/>`double`。因此解析器会检测一个<sp/>JSON<sp/>number<sp/>是否能转换至各种整数类型及<sp/>`double`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">8.<sp/>如何清空并最小化<sp/>`document`<sp/>或<sp/>`value`<sp/>的容量？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>调用<sp/>`SetXXX()`<sp/>方法<sp/>-<sp/>这些方法会调用析构函数，并重建空的<sp/>Object<sp/>或<sp/>Array:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Document<sp/>d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>d.SetObject();<sp/><sp/>//<sp/>clear<sp/>and<sp/>minimize</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>另外，也可以参考在<sp/>[C++<sp/>swap<sp/>with<sp/>temporary<sp/>idiom](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Clear-and-minimize)<sp/>中的一种等价的方法:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Value(kObjectType).Swap(d);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>或者，使用这个稍微长一点的代码也能完成同样的事情:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>d.Swap(Value(kObjectType).Move());<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">9.<sp/>如何将一个<sp/>`document`<sp/>节点插入到另一个<sp/>`document`<sp/>中？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>比如有以下两个<sp/>document(DOM):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Document<sp/>person;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>person.Parse(&quot;{\&quot;person\&quot;:{\&quot;name\&quot;:{\&quot;first\&quot;:\&quot;Adam\&quot;,\&quot;last\&quot;:\&quot;Thomas\&quot;}}}&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Document<sp/>address;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>address.Parse(&quot;{\&quot;address\&quot;:{\&quot;city\&quot;:\&quot;Moscow\&quot;,\&quot;street\&quot;:\&quot;Quiet\&quot;}}&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>假设我们希望将整个<sp/>`address`<sp/>插入到<sp/>`person`<sp/>中，作为其的一个子节点:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~js</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>{<sp/>&quot;person&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;name&quot;:<sp/>{<sp/>&quot;first&quot;:<sp/>&quot;Adam&quot;,<sp/>&quot;last&quot;:<sp/>&quot;Thomas&quot;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;address&quot;:<sp/>{<sp/>&quot;city&quot;:<sp/>&quot;Moscow&quot;,<sp/>&quot;street&quot;:<sp/>&quot;Quiet&quot;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>在插入节点的过程中需要注意<sp/>`document`<sp/>和<sp/>`value`<sp/>的生命周期并且正确地使用<sp/>allocator<sp/>进行内存分配和管理。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>一个简单有效的方法就是修改上述<sp/>`address`<sp/>变量的定义，让其使用<sp/>`person`<sp/>的<sp/>allocator<sp/>初始化，然后将其添加到根节点。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Documnet<sp/>address(&amp;person.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>person[&quot;person&quot;].AddMember(&quot;address&quot;,<sp/>address[&quot;address&quot;],<sp/>person.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>当然，如果你不想通过显式地写出<sp/>`address`<sp/>的<sp/>key<sp/>来得到其值，可以使用迭代器来实现:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>auto<sp/>addressRoot<sp/>=<sp/>address.MemberBegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>person[&quot;person&quot;].AddMember(addressRoot-&gt;name,<sp/>addressRoot-&gt;value,<sp/>person.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>此外，还可以通过深拷贝<sp/>address<sp/>document<sp/>来实现:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Value<sp/>addressValue<sp/>=<sp/>Value(address[&quot;address&quot;],<sp/>person.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>person[&quot;person&quot;].AddMember(&quot;address&quot;,<sp/>addressValue,<sp/>person.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Document/Value<sp/>(DOM)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>什么是转移语义？为什么？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>`Value`<sp/>不用复制语义，而使用了转移语义。这是指，当把来源值赋值于目标值时，来源值的所有权会转移至目标值。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>由于转移快于复制，此设计决定强迫使用者注意到复制的消耗。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>怎样去复制一个值？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>有两个<sp/>API<sp/>可用：含<sp/>allocator<sp/>的构造函数，以及<sp/>`CopyFrom()`。可参考<sp/>[深复制<sp/>Value](doc/tutorial.zh-cn.md)<sp/>里的用例。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>为什么我需要提供字符串的长度？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>由于<sp/>C<sp/>字符串是空字符结尾的，需要使用<sp/>`strlen()`<sp/>去计算其长度，这是线性复杂度的操作。若使用者已知字符串的长度，对很多操作来说会造成不必要的消耗。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>此外，RapidJSON<sp/>可处理含有<sp/>`\u0000`（空字符）的字符串。若一个字符串含有空字符，`strlen()`<sp/>便不能返回真正的字符串长度。在这种情况下使用者必须明确地提供字符串长度。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>为什么在许多<sp/>DOM<sp/>操作<sp/>API<sp/>中要提供分配器作为参数？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>由于这些<sp/>API<sp/>是<sp/>`Value`<sp/>的成员函数，我们不希望为每个<sp/>`Value`<sp/>储存一个分配器指针。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">5.<sp/>它会转换各种数值类型么？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>当使用<sp/>`GetInt()`、`GetUint()`<sp/>等<sp/>API<sp/>时，可能会发生转换。对于整数至整数转换，仅当保证转换安全才会转换（否则会断言失败）。然而，当把一个<sp/>64<sp/>位有号／无号整数转换至<sp/>double<sp/>时，它会转换，但有可能会损失精度。含有小数的数字、或大于<sp/>64<sp/>位的整数，都只能使用<sp/>`GetDouble()`<sp/>获取其值。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Reader/Writer<sp/>(SAX)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>为什么不仅仅用<sp/>`printf`<sp/>输出一个<sp/>JSON？为什么需要<sp/>`Writer`？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>最重要的是，`Writer`<sp/>能确保输出的<sp/>JSON<sp/>是格式正确的。错误地调用<sp/>SAX<sp/>事件（如<sp/>`StartObject()`<sp/>错配<sp/>`EndArray()`）会造成断言失败。此外，`Writer`<sp/>会把字符串进行转义（如<sp/>`\n`）。最后，`printf()`<sp/>的数值输出可能并不是一个合法的<sp/>JSON<sp/>number，特别是某些<sp/>locale<sp/>会有数字分隔符。而且<sp/>`Writer`<sp/>的数值字符串转换是使用非常快的算法来实现的，胜过<sp/>`printf()`<sp/>及<sp/>`iostream`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>我能否暂停解析过程，并在稍后继续？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>基于性能考虑，目前版本并不直接支持此功能。然而，若执行环境支持多线程，使用者可以在另一线程解析<sp/>JSON，并通过阻塞输入流去暂停。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Unicode</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>它是否支持<sp/>UTF-8、UTF-16<sp/>及其他格式？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>是。它完全支持<sp/>UTF-8、UTF-16（大端／小端）、UTF-32（大端／小端）及<sp/>ASCII。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>它能否检测编码的合法性？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>能。只需把<sp/>`kParseValidateEncodingFlag`<sp/>参考传给<sp/>`Parse()`。若发现在输入流中有非法的编码，它就会产生<sp/>`kParseErrorStringInvalidEncoding`<sp/>错误。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>什么是代理对（surrogate<sp/>pair)？RapidJSON<sp/>是否支持？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>JSON<sp/>使用<sp/>UTF-16<sp/>编码去转义<sp/>Unicode<sp/>字符，例如<sp/>`\u5927`<sp/>表示中文字“大”。要处理基本多文种平面（basic<sp/>multilingual<sp/>plane，BMP）以外的字符时，UTF-16<sp/>会把那些字符编码成两个<sp/>16<sp/>位值，这称为<sp/>UTF-16<sp/>代理对。例如，绘文字字符<sp/>U+1F602<sp/>在<sp/>JSON<sp/>中可被编码成<sp/>`\uD83D\uDE02`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>完全支持解析及生成<sp/>UTF-16<sp/>代理对。<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>它能否处理<sp/>JSON<sp/>字符串中的<sp/>`\u0000`（空字符）？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>能。RapidJSON<sp/>完全支持<sp/>JSON<sp/>字符串中的空字符。然而，使用者需要注意到这件事，并使用<sp/>`GetStringLength()`<sp/>及相关<sp/>API<sp/>去取得字符串真正长度。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">5.<sp/>能否对所有非<sp/>ASCII<sp/>字符输出成<sp/>`\uxxxx`<sp/>形式？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>可以。只要在<sp/>`Writer`<sp/>中使用<sp/>`ASCII&lt;&gt;`<sp/>作为输出编码参数，就可以强逼转义那些字符。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>流</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>我有一个很大的<sp/>JSON<sp/>文件。我应否把它整个载入内存中？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>使用者可使用<sp/>`FileReadStream`<sp/>去逐块读入文件。但若使用于原位解析，必须载入整个文件。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>我能否解析一个从网络上串流进来的<sp/>JSON？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>可以。使用者可根据<sp/>`FileReadStream`<sp/>的实现，去实现一个自定义的流。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>我不知道一些<sp/>JSON<sp/>将会使用哪种编码。怎样处理它们？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>你可以使用<sp/>`AutoUTFInputStream`，它能自动检测输入流的编码。然而，它会带来一些性能开销。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>什么是<sp/>BOM？RapidJSON<sp/>怎样处理它？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>[字节顺序标记（byte<sp/>order<sp/>mark,<sp/>BOM）](http://en.wikipedia.org/wiki/Byte_order_mark)<sp/>有时会出现于文件／流的开始，以表示其<sp/>UTF<sp/>编码类型。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>的<sp/>`EncodedInputStream`<sp/>可检测／跳过<sp/>BOM。`EncodedOutputStream`<sp/>可选择是否写入<sp/>BOM。可参考<sp/>[编码流](doc/stream.zh-cn.md)<sp/>中的例子。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">5.<sp/>为什么会涉及大端／小端？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>流的大端／小端是<sp/>UTF-16<sp/>及<sp/>UTF-32<sp/>流要处理的问题，而<sp/>UTF-8<sp/>不需要处理。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>性能</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>RapidJSON<sp/>是否真的快？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>是。它可能是最快的开源<sp/>JSON<sp/>库。有一个<sp/>[评测](https://github.com/miloyip/nativejson-benchmark)<sp/>评估<sp/>C/C++<sp/>JSON<sp/>库的性能。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>为什么它会快？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>的许多设计是针对时间／空间性能来设计的，这些决定可能会影响<sp/>API<sp/>的易用性。此外，它也使用了许多底层优化（内部函数／intrinsic、SIMD）及特别的算法（自定义的<sp/>double<sp/>至字符串转换、字符串至<sp/>double<sp/>的转换）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>什是是<sp/>SIMD？它如何用于<sp/>RapidJSON？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>[SIMD](http://en.wikipedia.org/wiki/SIMD)<sp/>指令可以在现代<sp/>CPU<sp/>中执行并行运算。RapidJSON<sp/>支持使用<sp/>Intel<sp/>的<sp/>SSE2/SSE4.2<sp/>和<sp/>ARM<sp/>的<sp/>Neon<sp/>来加速对空白符、制表符、回车符和换行符的过滤处理。在解析含缩进的<sp/>JSON<sp/>时，这能提升性能。只要定义名为<sp/>`RAPIDJSON_SSE2`<sp/>，`RAPIDJSON_SSE42`<sp/>或<sp/>`RAPIDJSON_NEON`<sp/>的宏，就能启动这个功能。然而，若在不支持这些指令集的机器上执行这些可执行文件，会导致崩溃。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>它会消耗许多内存么？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>RapidJSON<sp/>的设计目标是减低内存占用。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>在<sp/>SAX<sp/>API<sp/>中，`Reader`<sp/>消耗的内存与<sp/>JSON<sp/>树深度加上最长<sp/>JSON<sp/>字符成正比。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>在<sp/>DOM<sp/>API<sp/>中，每个<sp/>`Value`<sp/>在<sp/>32/64<sp/>位架构下分别消耗<sp/>16/24<sp/>字节。RapidJSON<sp/>也使用一个特殊的内存分配器去减少分配的额外开销。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">5.<sp/>高性能的意义何在？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>有些应用程序需要处理非常大的<sp/>JSON<sp/>文件。而有些后台应用程序需要处理大量的<sp/>JSON。达到高性能同时改善延时及吞吐量。更广义来说，这也可以节省能源。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>八卦</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>谁是<sp/>RapidJSON<sp/>的开发者？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>叶劲峰（Milo<sp/>Yip，[miloyip](https://github.com/miloyip)）是<sp/>RapidJSON<sp/>的原作者。全世界许多贡献者一直在改善<sp/>RapidJSON。Philipp<sp/>A.<sp/>Hartmann（[pah](https://github.com/pah)）实现了许多改进，也设置了自动化测试，而且还参与许多社区讨论。丁欧南（Don<sp/>Ding，[thebusytypist](https://github.com/thebusytypist)）实现了迭代式解析器。Andrii<sp/>Senkovych（[jollyroger](https://github.com/jollyroger)）完成了向<sp/>CMake<sp/>的迁移。Kosta（[Kosta-Github](https://github.com/Kosta-Github)）提供了一个非常灵巧的短字符串优化。也需要感谢其他献者及社区成员。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">2.<sp/>为何你要开发<sp/>RapidJSON？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>在<sp/>2011<sp/>年开始这项目时，它只是一个兴趣项目。Milo<sp/>Yip<sp/>是一个游戏程序员，他在那时候认识到<sp/>JSON<sp/>并希望在未来的项目中使用。由于<sp/>JSON<sp/>好像很简单，他希望写一个快速的仅有头文件的程序库。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">3.<sp/>为什么开发中段有一段长期空档？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>主要是个人因素，例如加入新家庭成员。另外，Milo<sp/>Yip<sp/>也花了许多业余时间去翻译<sp/>Jason<sp/>Gregory<sp/>的《Game<sp/>Engine<sp/>Architecture》至中文版《游戏引擎架构》。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">4.<sp/>为什么这个项目从<sp/>Google<sp/>Code<sp/>搬到<sp/>GitHub？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>这是大势所趋，而且<sp/>GitHub<sp/>更为强大及方便。</highlight></codeline>
    </programlisting>
    <location file="src/rapidjson/doc/faq.zh-cn.md"/>
  </compounddef>
</doxygen>
