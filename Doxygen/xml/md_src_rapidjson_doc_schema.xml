<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="md_src_rapidjson_doc_schema" kind="page">
    <compoundname>md_src_rapidjson_doc_schema</compoundname>
    <title>Schema</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>(This feature was released in v1.1.0)</para>
<para>JSON <ref refid="class_schema" kindref="compound">Schema</ref> is a draft standard for describing the format of JSON data. The schema itself is also JSON data. By validating a JSON structure with JSON <ref refid="class_schema" kindref="compound">Schema</ref>, your code can safely access the DOM without manually checking types, or whether a key exists, etc. It can also ensure that the serialized JSON conform to a specified schema.</para>
<para>RapidJSON implemented a JSON <ref refid="class_schema" kindref="compound">Schema</ref> validator for <ulink url="http://json-schema.org/documentation.html">JSON Schema Draft v4</ulink>. If you are not familiar with JSON <ref refid="class_schema" kindref="compound">Schema</ref>, you may refer to <ulink url="http://spacetelescope.github.io/understanding-json-schema/">Understanding JSON Schema</ulink>.</para>
<sect1 id="md_src_rapidjson_doc_schema_1Basic">
<title>Basic Usage</title>
<para>First of all, you need to parse a JSON <ref refid="class_schema" kindref="compound">Schema</ref> into <computeroutput>Document</computeroutput>, and then compile the <computeroutput>Document</computeroutput> into a <computeroutput>SchemaDocument</computeroutput>.</para>
<para>Secondly, construct a <computeroutput>SchemaValidator</computeroutput> with the <computeroutput>SchemaDocument</computeroutput>. It is similar to a <computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput> in the sense of handling SAX events. So, you can use <computeroutput>document.Accept(validator)</computeroutput> to validate a document, and then check the validity.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&quot;<ref refid="schema_8h" kindref="compound">rapidjson/schema.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">Document</ref><sp/>sd;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sd.<ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">Parse</ref>(schemaJson).<ref refid="class_generic_document_1a510a0588db4eb372f5d81bc3646578fb" kindref="member">HasParseError</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>schema<sp/>is<sp/>not<sp/>a<sp/>valid<sp/>JSON.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_schema_document" kindref="compound">SchemaDocument</ref><sp/>schema(sd);<sp/></highlight><highlight class="comment">//<sp/>Compile<sp/>a<sp/>Document<sp/>to<sp/>SchemaDocument</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>sd<sp/>is<sp/>no<sp/>longer<sp/>needed<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">Document</ref><sp/>d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d.<ref refid="class_generic_document_1a901db1678f99a1b550003eed75bc380a" kindref="member">Parse</ref>(inputJson).<ref refid="class_generic_document_1a510a0588db4eb372f5d81bc3646578fb" kindref="member">HasParseError</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>input<sp/>is<sp/>not<sp/>a<sp/>valid<sp/>JSON.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_schema_validator" kindref="compound">SchemaValidator</ref><sp/>validator(schema);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!d.Accept(validator))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Input<sp/>JSON<sp/>is<sp/>invalid<sp/>according<sp/>to<sp/>the<sp/>schema</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>diagnostic<sp/>information</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_generic_string_buffer" kindref="compound">StringBuffer</ref><sp/>sb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>validator.GetInvalidSchemaPointer().StringifyUriFragment(sb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>schema:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>sb.<ref refid="class_generic_string_buffer_1a42079865bab1deb930c6cff7d491c719" kindref="member">GetString</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>keyword:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>validator.GetInvalidSchemaKeyword());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sb.<ref refid="class_generic_string_buffer_1a42f15c959046d899cb74c3120a6995f9" kindref="member">Clear</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>validator.GetInvalidDocumentPointer().StringifyUriFragment(sb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>document:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>sb.<ref refid="class_generic_string_buffer_1a42079865bab1deb930c6cff7d491c719" kindref="member">GetString</ref>());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Some notes:</para>
<para><itemizedlist>
<listitem><para>One <computeroutput>SchemaDocument</computeroutput> can be referenced by multiple <computeroutput>SchemaValidator</computeroutput>s. It will not be modified by <computeroutput>SchemaValidator</computeroutput>s.</para>
</listitem><listitem><para>A <computeroutput>SchemaValidator</computeroutput> may be reused to validate multiple documents. To run it for other documents, call <computeroutput>validator.Reset()</computeroutput> first.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="md_src_rapidjson_doc_schema_1Fused">
<title>Validation during parsing/serialization</title>
<para>Unlike most JSON <ref refid="class_schema" kindref="compound">Schema</ref> validator implementations, RapidJSON provides a SAX-based schema validator. Therefore, you can parse a JSON from a stream while validating it on the fly. If the validator encounters a JSON value that invalidates the supplied schema, the parsing will be terminated immediately. This design is especially useful for parsing large JSON files.</para>
<sect2 id="md_src_rapidjson_doc_schema_1DOM">
<title>DOM parsing</title>
<para>For using DOM in parsing, <computeroutput>Document</computeroutput> needs some preparation and finalizing tasks, in addition to receiving SAX events, thus it needs some work to route the reader, validator and the document. <computeroutput><ref refid="class_schema_validating_reader" kindref="compound">SchemaValidatingReader</ref></computeroutput> is a helper class that doing such work.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&quot;<ref refid="filereadstream_8h" kindref="compound">rapidjson/filereadstream.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_schema_document" kindref="compound">SchemaDocument</ref><sp/>schema(sd);<sp/></highlight><highlight class="comment">//<sp/>Compile<sp/>a<sp/>Document<sp/>to<sp/>SchemaDocument</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Use<sp/>reader<sp/>to<sp/>parse<sp/>the<sp/>JSON</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>fp<sp/>=<sp/>fopen(</highlight><highlight class="stringliteral">&quot;big.json&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;r&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_file_read_stream" kindref="compound">FileReadStream</ref><sp/>is(fp,<sp/>buffer,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(buffer));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Parse<sp/>JSON<sp/>from<sp/>reader,<sp/>validate<sp/>the<sp/>SAX<sp/>events,<sp/>and<sp/>store<sp/>in<sp/>d.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_generic_document" kindref="compound">Document</ref><sp/>d;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_schema_validating_reader" kindref="compound">SchemaValidatingReader&lt;kParseDefaultFlags, FileReadStream, UTF8&lt;&gt;</ref><sp/>&gt;<sp/>reader(is,<sp/>schema);</highlight></codeline>
<codeline><highlight class="normal">d.<ref refid="class_generic_document_1ac30b4e8887974060b695be20c3ceb02c" kindref="member">Populate</ref>(reader);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!reader.GetParseResult())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Not<sp/>a<sp/>valid<sp/>JSON</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>When<sp/>reader.GetParseResult().Code()<sp/>==<sp/>kParseErrorTermination,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it<sp/>may<sp/>be<sp/>terminated<sp/>by:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(1)<sp/>the<sp/>validator<sp/>found<sp/>that<sp/>the<sp/>JSON<sp/>is<sp/>invalid<sp/>according<sp/>to<sp/>schema;<sp/>or</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(2)<sp/>the<sp/>input<sp/>stream<sp/>has<sp/>I/O<sp/>error.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>the<sp/>validation<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!reader.IsValid())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Input<sp/>JSON<sp/>is<sp/>invalid<sp/>according<sp/>to<sp/>the<sp/>schema</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>diagnostic<sp/>information</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="class_generic_string_buffer" kindref="compound">StringBuffer</ref><sp/>sb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reader.GetInvalidSchemaPointer().StringifyUriFragment(sb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>schema:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>sb.<ref refid="class_generic_string_buffer_1a42079865bab1deb930c6cff7d491c719" kindref="member">GetString</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>keyword:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>reader.GetInvalidSchemaKeyword());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sb.<ref refid="class_generic_string_buffer_1a42f15c959046d899cb74c3120a6995f9" kindref="member">Clear</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reader.GetInvalidDocumentPointer().StringifyUriFragment(sb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>document:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>sb.<ref refid="class_generic_string_buffer_1a42079865bab1deb930c6cff7d491c719" kindref="member">GetString</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_1SAX">
<title>SAX parsing</title>
<para>For using SAX in parsing, it is much simpler. If it only need to validate the JSON without further processing, it is simply:</para>
<para><programlisting><codeline><highlight class="normal">SchemaValidator<sp/>validator(schema);</highlight></codeline>
<codeline><highlight class="normal">Reader<sp/>reader;</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(!reader.Parse(stream,<sp/>validator))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!validator.IsValid())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This is exactly the method used in the <ulink url="example/schemavalidator/schemavalidator.cpp">schemavalidator</ulink> example. The distinct advantage is low memory usage, no matter how big the JSON was (the memory usage depends on the complexity of the schema).</para>
<para>If you need to handle the SAX events further, then you need to use the template class <computeroutput><ref refid="class_generic_schema_validator" kindref="compound">GenericSchemaValidator</ref></computeroutput> to set the output handler of the validator:</para>
<para><programlisting><codeline><highlight class="normal">MyHandler<sp/>handler;</highlight></codeline>
<codeline><highlight class="normal">GenericSchemaValidator&lt;SchemaDocument,<sp/>MyHandler&gt;<sp/>validator(schema,<sp/>handler);</highlight></codeline>
<codeline><highlight class="normal">Reader<sp/>reader;</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(!reader.Parse(ss,<sp/>validator))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!validator.IsValid())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_zh_cn_1Serialization">
<title>Serialization</title>
<para>It is also possible to do validation during serializing. This can ensure the result JSON is valid according to the JSON schema.</para>
<para><programlisting><codeline><highlight class="normal">StringBuffer<sp/>sb;</highlight></codeline>
<codeline><highlight class="normal">Writer&lt;StringBuffer&gt;<sp/>writer(sb);</highlight></codeline>
<codeline><highlight class="normal">GenericSchemaValidator&lt;SchemaDocument,<sp/>Writer&lt;StringBuffer&gt;<sp/>&gt;<sp/>validator(s,<sp/>writer);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(!d.Accept(validator))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Some<sp/>problem<sp/>during<sp/>Accept(),<sp/>it<sp/>may<sp/>be<sp/>validation<sp/>or<sp/>encoding<sp/>issues.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!validator.IsValid())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Of course, if your application only needs SAX-style serialization, it can simply send SAX events to <computeroutput>SchemaValidator</computeroutput> instead of <computeroutput><ref refid="class_writer" kindref="compound">Writer</ref></computeroutput>.</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_schema_1Remote">
<title>Remote Schema</title>
<para>JSON <ref refid="class_schema" kindref="compound">Schema</ref> supports <ulink url="http://spacetelescope.github.io/understanding-json-schema/structuring.html"><computeroutput>$ref</computeroutput> keyword</ulink>, which is a <ref refid="pointer_8md" kindref="compound">JSON pointer</ref> referencing to a local or remote schema. Local pointer is prefixed with <computeroutput>#</computeroutput>, while remote pointer is an relative or absolute URI. For example:</para>
<para><programlisting filename=".js"><codeline><highlight class="normal">{<sp/>&quot;$ref&quot;:<sp/>&quot;definitions.json#/address&quot;<sp/>}</highlight></codeline>
</programlisting></para>
<para>As <computeroutput>SchemaDocument</computeroutput> does not know how to resolve such URI, it needs a user-provided <computeroutput>IRemoteSchemaDocumentProvider</computeroutput> instance to do so.</para>
<para><programlisting><codeline><highlight class="normal">class<sp/>MyRemoteSchemaDocumentProvider<sp/>:<sp/>public<sp/>IRemoteSchemaDocumentProvider<sp/>{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>const<sp/>SchemaDocument*<sp/>GetRemoteDocument(const<sp/>char*<sp/>uri,<sp/>SizeType<sp/>length)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Resolve<sp/>the<sp/>uri<sp/>and<sp/>returns<sp/>a<sp/>pointer<sp/>to<sp/>that<sp/>schema.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">MyRemoteSchemaDocumentProvider<sp/>provider;</highlight></codeline>
<codeline><highlight class="normal">SchemaDocument<sp/>schema(sd,<sp/>&amp;provider);</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_src_rapidjson_doc_schema_zh_cn_1Conformance">
<title>Conformance</title>
<para>RapidJSON passed 262 out of 263 tests in <ulink url="https://github.com/json-schema/JSON-Schema-Test-Suite">JSON Schema Test Suite</ulink> (Json <ref refid="class_schema" kindref="compound">Schema</ref> draft 4).</para>
<para>The failed test is &quot;changed scope ref invalid&quot; of &quot;change resolution scope&quot; in <computeroutput>refRemote.json</computeroutput>. It is due to that <computeroutput>id</computeroutput> schema keyword and URI combining function are not implemented.</para>
<para>Besides, the <computeroutput>format</computeroutput> schema keyword for string values is ignored, since it is not required by the specification.</para>
<sect2 id="md_src_rapidjson_doc_schema_1Regex">
<title>Regular Expression</title>
<para>The schema keyword <computeroutput>pattern</computeroutput> and <computeroutput>patternProperties</computeroutput> uses regular expression to match the required pattern.</para>
<para>RapidJSON implemented a simple NFA regular expression engine, which is used by default. It supports the following syntax.</para>
<para><table rows="25" cols="2"><row>
<entry thead="yes"><para>Syntax   </para>
</entry><entry thead="yes"><para>Description    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ab</computeroutput>   </para>
</entry><entry thead="no"><para>Concatenation    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a&amp;#124;b</computeroutput>   </para>
</entry><entry thead="no"><para>Alternation    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a?</computeroutput>   </para>
</entry><entry thead="no"><para>Zero or one    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a*</computeroutput>   </para>
</entry><entry thead="no"><para>Zero or more    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a+</computeroutput>   </para>
</entry><entry thead="no"><para>One or more    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a{3}</computeroutput>   </para>
</entry><entry thead="no"><para>Exactly 3 times    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a{3,}</computeroutput>   </para>
</entry><entry thead="no"><para>At least 3 times    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a{3,5}</computeroutput>   </para>
</entry><entry thead="no"><para>3 to 5 times    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>(ab)</computeroutput>   </para>
</entry><entry thead="no"><para>Grouping    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>^a</computeroutput>   </para>
</entry><entry thead="no"><para>At the beginning    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>a$</computeroutput>   </para>
</entry><entry thead="no"><para>At the end    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>.</computeroutput>   </para>
</entry><entry thead="no"><para>Any character    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>[abc]</computeroutput>   </para>
</entry><entry thead="no"><para>Character classes    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>[a-c]</computeroutput>   </para>
</entry><entry thead="no"><para>Character class range    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>[a-z0-9_]</computeroutput>   </para>
</entry><entry thead="no"><para>Character class combination    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>[^abc]</computeroutput>   </para>
</entry><entry thead="no"><para>Negated character classes    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>[^a-c]</computeroutput>   </para>
</entry><entry thead="no"><para>Negated character class range    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>[\b]</computeroutput>   </para>
</entry><entry thead="no"><para>Backspace (U+0008)    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>\&amp;#124;</computeroutput>, <computeroutput>\\</computeroutput>, ...   </para>
</entry><entry thead="no"><para>Escape characters    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>\f</computeroutput>   </para>
</entry><entry thead="no"><para>Form feed (U+000C)    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>\n</computeroutput>   </para>
</entry><entry thead="no"><para>Line feed (U+000A)    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>\r</computeroutput>   </para>
</entry><entry thead="no"><para>Carriage return (U+000D)    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>\t</computeroutput>   </para>
</entry><entry thead="no"><para>Tab (U+0009)    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>\v</computeroutput>   </para>
</entry><entry thead="no"><para>Vertical tab (U+000B)   </para>
</entry></row>
</table>
</para>
<para>For C++11 compiler, it is also possible to use the <computeroutput>std::regex</computeroutput> by defining <computeroutput>RAPIDJSON_SCHEMA_USE_INTERNALREGEX=0</computeroutput> and <computeroutput>RAPIDJSON_SCHEMA_USE_STDREGEX=1</computeroutput>. If your schemas do not need <computeroutput>pattern</computeroutput> and <computeroutput>patternProperties</computeroutput>, you can set both macros to zero to disable this feature, which will reduce some code size.</para>
</sect2>
</sect1>
<sect1 id="md_src_rapidjson_doc_schema_zh_cn_1Performance">
<title>Performance</title>
<para>Most C++ JSON libraries do not yet support JSON <ref refid="class_schema" kindref="compound">Schema</ref>. So we tried to evaluate the performance of RapidJSON&apos;s JSON <ref refid="class_schema" kindref="compound">Schema</ref> validator according to <ulink url="https://github.com/ebdrup/json-schema-benchmark">json-schema-benchmark</ulink>, which tests 11 JavaScript libraries running on Node.js.</para>
<para>That benchmark runs validations on <ulink url="https://github.com/json-schema/JSON-Schema-Test-Suite">JSON Schema Test Suite</ulink>, in which some test suites and tests are excluded. We made the same benchmarking procedure in <ulink url="test/perftest/schematest.cpp"><computeroutput>schematest.cpp</computeroutput></ulink>.</para>
<para>On a Mac Book Pro (2.8 GHz Intel Core i7), the following results are collected.</para>
<para><table rows="13" cols="3"><row>
<entry thead="yes"><para>Validator   </para>
</entry><entry thead="yes" align='center'><para>Relative speed   </para>
</entry><entry thead="yes" align='center'><para>Number of test runs per second    </para>
</entry></row>
<row>
<entry thead="no"><para>RapidJSON   </para>
</entry><entry thead="no" align='center'><para>155%   </para>
</entry><entry thead="no" align='center'><para>30682    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/epoberezkin/ajv"><computeroutput>ajv</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>100%   </para>
</entry><entry thead="no" align='center'><para>19770 (± 1.31%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/mafintosh/is-my-json-valid"><computeroutput>is-my-json-valid</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>70%   </para>
</entry><entry thead="no" align='center'><para>13835 (± 2.84%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/bugventure/jsen"><computeroutput>jsen</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>57.7%   </para>
</entry><entry thead="no" align='center'><para>11411 (± 1.27%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/AlexeyGrishin/schemasaurus"><computeroutput>schemasaurus</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>26%   </para>
</entry><entry thead="no" align='center'><para>5145 (± 1.62%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/playlyfe/themis"><computeroutput>themis</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>19.9%   </para>
</entry><entry thead="no" align='center'><para>3935 (± 2.69%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/zaggino/z-schema"><computeroutput>z-schema</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>7%   </para>
</entry><entry thead="no" align='center'><para>1388 (± 0.84%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/pandastrike/jsck#readme"><computeroutput>jsck</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>3.1%   </para>
</entry><entry thead="no" align='center'><para>606 (± 2.84%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/tdegrunt/jsonschema#readme"><computeroutput>jsonschema</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>0.9%   </para>
</entry><entry thead="no" align='center'><para>185 (± 1.01%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/Prestaul/skeemas#readme"><computeroutput>skeemas</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>0.8%   </para>
</entry><entry thead="no" align='center'><para>154 (± 0.79%)    </para>
</entry></row>
<row>
<entry thead="no"><para>tv4   </para>
</entry><entry thead="no" align='center'><para>0.5%   </para>
</entry><entry thead="no" align='center'><para>93 (± 0.94%)    </para>
</entry></row>
<row>
<entry thead="no"><para><ulink url="https://github.com/natesilva/jayschema"><computeroutput>jayschema</computeroutput></ulink>   </para>
</entry><entry thead="no" align='center'><para>0.1%   </para>
</entry><entry thead="no" align='center'><para>21 (± 1.14%)   </para>
</entry></row>
</table>
</para>
<para>That is, RapidJSON is about 1.5x faster than the fastest JavaScript library (ajv). And 1400x faster than the slowest one.</para>
</sect1>
<sect1 id="md_src_rapidjson_doc_schema_1Reporting">
<title>Schema violation reporting</title>
<para>(Unreleased as of 2017-09-20)</para>
<para>When validating an instance against a JSON <ref refid="class_schema" kindref="compound">Schema</ref>, it is often desirable to report not only whether the instance is valid, but also the ways in which it violates the schema.</para>
<para>The <computeroutput>SchemaValidator</computeroutput> class collects errors encountered during validation into a JSON <computeroutput>Value</computeroutput>. This error object can then be accessed as <computeroutput>validator.GetError()</computeroutput>.</para>
<para>The structure of the error object is subject to change in future versions of RapidJSON, as there is no standard schema for violations. The details below this point are provisional only.</para>
<sect2 id="md_src_rapidjson_doc_schema_1ReportingGeneral">
<title>General provisions</title>
<para>Validation of an instance value against a schema produces an error value. The error value is always an object. An empty object <computeroutput>{}</computeroutput> indicates the instance is valid.</para>
<para><itemizedlist>
<listitem><para>The name of each member corresponds to the JSON <ref refid="class_schema" kindref="compound">Schema</ref> keyword that is violated.</para>
</listitem><listitem><para>The value is either an object describing a single violation, or an array of such objects.</para>
</listitem></itemizedlist>
</para>
<para>Each violation object contains two string-valued members named <computeroutput>instanceRef</computeroutput> and <computeroutput>schemaRef</computeroutput>. <computeroutput>instanceRef</computeroutput> contains the URI fragment serialization of a JSON Pointer to the instance subobject in which the violation was detected. <computeroutput>schemaRef</computeroutput> contains the URI of the schema and the fragment serialization of a JSON Pointer to the subschema that was violated.</para>
<para>Individual violation objects can contain other keyword-specific members. These are detailed further.</para>
<para>For example, validating this instance:</para>
<para><programlisting filename=".json"><codeline><highlight class="normal">{&quot;numbers&quot;:<sp/>[1,<sp/>2,<sp/>&quot;3&quot;,<sp/>4,<sp/>5]}</highlight></codeline>
</programlisting></para>
<para>against this schema:</para>
<para><programlisting filename=".json"><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;type&quot;:<sp/>&quot;object&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;properties&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;numbers&quot;:<sp/>{&quot;$ref&quot;:<sp/>&quot;numbers.schema.json&quot;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>where <computeroutput>numbers.schema.json</computeroutput> refers (via a suitable <computeroutput>IRemoteSchemaDocumentProvider</computeroutput>) to this schema:</para>
<para><programlisting filename=".json"><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;type&quot;:<sp/>&quot;array&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;items&quot;:<sp/>{&quot;type&quot;:<sp/>&quot;number&quot;}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>produces the following error object:</para>
<para><programlisting filename=".json"><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;type&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;instanceRef&quot;:<sp/>&quot;#/numbers/2&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;schemaRef&quot;:<sp/>&quot;numbers.schema.json#/items&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;expected&quot;:<sp/>[&quot;number&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;actual&quot;:<sp/>&quot;string&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_1Numbers">
<title>Validation keywords for numbers</title>
<sect3 id="md_src_rapidjson_doc_schema_1multipleof">
<title>multipleOf</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required number strictly greater than 0. The value of the <computeroutput>multipleOf</computeroutput> keyword specified in the schema.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required number. The instance value.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1maximum">
<title>maximum</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required number. The value of the <computeroutput>maximum</computeroutput> keyword specified in the schema.</para>
</listitem><listitem><para><computeroutput>exclusiveMaximum</computeroutput>: optional boolean. This will be true if the schema specified <computeroutput>&quot;exclusiveMaximum&quot;: true</computeroutput>, and will be omitted otherwise.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required number. The instance value.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1minimum">
<title>minimum</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required number. The value of the <computeroutput>minimum</computeroutput> keyword specified in the schema.</para>
</listitem><listitem><para><computeroutput>exclusiveMinimum</computeroutput>: optional boolean. This will be true if the schema specified <computeroutput>&quot;exclusiveMinimum&quot;: true</computeroutput>, and will be omitted otherwise.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required number. The instance value.</para>
</listitem></itemizedlist>
</para>
</sect3>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_1Strings">
<title>Validation keywords for strings</title>
<sect3 id="md_src_rapidjson_doc_schema_1maxLength">
<title>maxLength</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required number greater than or equal to 0. The value of the <computeroutput>maxLength</computeroutput> keyword specified in the schema.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required string. The instance value.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1minLength">
<title>minLength</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required number greater than or equal to 0. The value of the <computeroutput>minLength</computeroutput> keyword specified in the schema.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required string. The instance value.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1pattern">
<title>pattern</title>
<para><itemizedlist>
<listitem><para><computeroutput>actual</computeroutput>: required string. The instance value.</para>
</listitem></itemizedlist>
</para>
<para>(The expected pattern is not reported because the internal representation in <computeroutput>SchemaDocument</computeroutput> does not store the pattern in original string form.)</para>
</sect3>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_1Arrays">
<title>Validation keywords for arrays</title>
<sect3 id="md_src_rapidjson_doc_schema_1additionalItems">
<title>additionalItems</title>
<para>This keyword is reported when the value of <computeroutput>items</computeroutput> schema keyword is an array, the value of <computeroutput>additionalItems</computeroutput> is <computeroutput>false</computeroutput>, and the instance is an array with more items than specified in the <computeroutput>items</computeroutput> array.</para>
<para><itemizedlist>
<listitem><para><computeroutput>disallowed</computeroutput>: required integer greater than or equal to 0. The index of the first item that has no corresponding schema.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1maxItems-minItems">
<title>maxItems and minItems</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required integer greater than or equal to 0. The value of <computeroutput>maxItems</computeroutput> (respectively, <computeroutput>minItems</computeroutput>) specified in the schema.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required integer greater than or equal to 0. Number of items in the instance array.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1uniqueItems">
<title>uniqueItems</title>
<para><itemizedlist>
<listitem><para><computeroutput>duplicates</computeroutput>: required array whose items are integers greater than or equal to 0. Indices of items of the instance that are equal.</para>
</listitem></itemizedlist>
</para>
<para>(RapidJSON only reports the first two equal items, for performance reasons.)</para>
</sect3>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_1autotoc_md115">
<title>Validation keywords for objects</title>
<sect3 id="md_src_rapidjson_doc_schema_1maxProperties-minProperties">
<title>maxProperties and minProperties</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required integer greater than or equal to 0. The value of <computeroutput>maxProperties</computeroutput> (respectively, <computeroutput>minProperties</computeroutput>) specified in the schema.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required integer greater than or equal to 0. Number of properties in the instance object.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1required">
<title>required</title>
<para><itemizedlist>
<listitem><para><computeroutput>missing</computeroutput>: required array of one or more unique strings. The names of properties that are listed in the value of the <computeroutput>required</computeroutput> schema keyword but not present in the instance object.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1additionalProperties">
<title>additionalProperties</title>
<para>This keyword is reported when the schema specifies <computeroutput>additionalProperties: false</computeroutput> and the name of a property of the instance is neither listed in the <computeroutput>properties</computeroutput> keyword nor matches any regular expression in the <computeroutput>patternProperties</computeroutput> keyword.</para>
<para><itemizedlist>
<listitem><para><computeroutput>disallowed</computeroutput>: required string. Name of the offending property of the instance.</para>
</listitem></itemizedlist>
</para>
<para>(For performance reasons, RapidJSON only reports the first such property encountered.)</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1dependencies">
<title>dependencies</title>
<para><itemizedlist>
<listitem><para><computeroutput>errors</computeroutput>: required object with one or more properties. Names and values of its properties are described below.</para>
</listitem></itemizedlist>
</para>
<para>Recall that JSON <ref refid="class_schema" kindref="compound">Schema</ref> Draft 04 supports <emphasis>schema dependencies</emphasis>, where presence of a named <emphasis>controlling</emphasis> property requires the instance object to be valid against a subschema, and <emphasis>property dependencies</emphasis>, where presence of a controlling property requires other <emphasis>dependent</emphasis> properties to be also present.</para>
<para>For a violated schema dependency, <computeroutput>errors</computeroutput> will contain a property with the name of the controlling property and its value will be the error object produced by validating the instance object against the dependent schema.</para>
<para>For a violated property dependency, <computeroutput>errors</computeroutput> will contain a property with the name of the controlling property and its value will be an array of one or more unique strings listing the missing dependent properties.</para>
</sect3>
</sect2>
<sect2 id="md_src_rapidjson_doc_schema_1AnyTypes">
<title>Validation keywords for any instance type</title>
<sect3 id="md_src_rapidjson_doc_schema_1enum">
<title>enum</title>
<para>This keyword has no additional properties beyond <computeroutput>instanceRef</computeroutput> and <computeroutput>schemaRef</computeroutput>.</para>
<para><itemizedlist>
<listitem><para>The allowed values are not listed because <computeroutput>SchemaDocument</computeroutput> does not store them in original form.</para>
</listitem><listitem><para>The violating value is not reported because it might be unwieldy.</para>
</listitem></itemizedlist>
</para>
<para>If you need to report these details to your users, you can access the necessary information by following <computeroutput>instanceRef</computeroutput> and <computeroutput>schemaRef</computeroutput>.</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1type">
<title>type</title>
<para><itemizedlist>
<listitem><para><computeroutput>expected</computeroutput>: required array of one or more unique strings, each of which is one of the seven primitive types defined by the JSON <ref refid="class_schema" kindref="compound">Schema</ref> Draft 04 Core specification. Lists the types allowed by the <computeroutput>type</computeroutput> schema keyword.</para>
</listitem><listitem><para><computeroutput>actual</computeroutput>: required string, also one of seven primitive types. The primitive type of the instance.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1allOf-anyOf-oneOf">
<title>allOf, anyOf, and oneOf</title>
<para><itemizedlist>
<listitem><para><computeroutput>errors</computeroutput>: required array of at least one object. There will be as many items as there are subschemas in the <computeroutput>allOf</computeroutput>, <computeroutput>anyOf</computeroutput> or <computeroutput>oneOf</computeroutput> schema keyword, respectively. Each item will be the error value produced by validating the instance against the corresponding subschema.</para>
</listitem></itemizedlist>
</para>
<para>For <computeroutput>allOf</computeroutput>, at least one error value will be non-empty. For <computeroutput>anyOf</computeroutput>, all error values will be non-empty. For <computeroutput>oneOf</computeroutput>, either all error values will be non-empty, or more than one will be empty.</para>
</sect3>
<sect3 id="md_src_rapidjson_doc_schema_1not">
<title>not</title>
<para>This keyword has no additional properties apart from <computeroutput>instanceRef</computeroutput> and <computeroutput>schemaRef</computeroutput>. </para>
</sect3>
</sect2>
</sect1>
    </detaileddescription>
    <location file="src/rapidjson/doc/schema.md"/>
  </compounddef>
</doxygen>
