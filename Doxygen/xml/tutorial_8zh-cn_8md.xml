<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="tutorial_8zh-cn_8md" kind="file" language="Markdown">
    <compoundname>tutorial.zh-cn.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#<sp/>教程</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">本教程简介文件对象模型（Document<sp/>Object<sp/>Model,<sp/>DOM）API。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">如<sp/>[用法一览](../readme.zh-cn.md#用法一览)<sp/>中所示，可以解析一个<sp/>JSON<sp/>至<sp/>DOM，然后就可以轻松查询及修改<sp/>DOM，并最终转换回<sp/>JSON。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">[TOC]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Value<sp/>及<sp/>Document<sp/>{#ValueDocument}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">每个<sp/>JSON<sp/>值都储存为<sp/>`Value`<sp/>类，而<sp/>`Document`<sp/>类则表示整个<sp/>DOM，它存储了一个<sp/>DOM<sp/>树的根<sp/>`Value`。RapidJSON<sp/>的所有公开类型及函数都在<sp/>`rapidjson`<sp/>命名空间中。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>查询<sp/>Value<sp/>{#QueryValue}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">在本节中，我们会使用到<sp/>`example/tutorial/tutorial.cpp`<sp/>中的代码片段。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">假设我们用<sp/>C<sp/>语言的字符串储存一个<sp/>JSON（`const<sp/>char*<sp/>json`）：</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~js</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;hello&quot;:<sp/>&quot;world&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;t&quot;:<sp/>true<sp/>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;f&quot;:<sp/>false,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;n&quot;:<sp/>null,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;i&quot;:<sp/>123,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;pi&quot;:<sp/>3.1416,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;a&quot;:<sp/>[1,<sp/>2,<sp/>3,<sp/>4]</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">把它解析至一个<sp/>`Document`：</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;rapidjson/document.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>rapidjson;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">Document<sp/>document;</highlight></codeline>
<codeline><highlight class="normal">document.Parse(json);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">那么现在该<sp/>JSON<sp/>就会被解析至<sp/>`document`<sp/>中，成为一棵<sp/>*DOM<sp/>树<sp/>*:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">![教程中的<sp/>DOM](diagram/tutorial.png)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">自从<sp/>RFC<sp/>7159<sp/>作出更新，合法<sp/>JSON<sp/>文件的根可以是任何类型的<sp/>JSON<sp/>值。而在较早的<sp/>RFC<sp/>4627<sp/>中，根值只允许是<sp/>Object<sp/>或<sp/>Array。而在上述例子中，根是一个<sp/>Object。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">assert(document.IsObject());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">让我们查询一下根<sp/>Object<sp/>中有没有<sp/>`&quot;hello&quot;`<sp/>成员。由于一个<sp/>`Value`<sp/>可包含不同类型的值，我们可能需要验证它的类型，并使用合适的<sp/>API<sp/>去获取其值。在此例中，`&quot;hello&quot;`<sp/>成员关联到一个<sp/>JSON<sp/>String。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">assert(document.HasMember(&quot;hello&quot;));</highlight></codeline>
<codeline><highlight class="normal">assert(document[&quot;hello&quot;].IsString());</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;hello<sp/>=<sp/>%s\n&quot;,<sp/>document[&quot;hello&quot;].GetString());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">world</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">JSON<sp/>True/False<sp/>值是以<sp/>`bool`<sp/>表示的。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">assert(document[&quot;t&quot;].IsBool());</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;t<sp/>=<sp/>%s\n&quot;,<sp/>document[&quot;t&quot;].GetBool()<sp/>?<sp/>&quot;true&quot;<sp/>:<sp/>&quot;false&quot;);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">true</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">JSON<sp/>Null<sp/>值可用<sp/>`IsNull()`<sp/>查询。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;n<sp/>=<sp/>%s\n&quot;,<sp/>document[&quot;n&quot;].IsNull()<sp/>?<sp/>&quot;null&quot;<sp/>:<sp/>&quot;?&quot;);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">null</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">JSON<sp/>Number<sp/>类型表示所有数值。然而，C++<sp/>需要使用更专门的类型。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">assert(document[&quot;i&quot;].IsNumber());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>在此情况下，IsUint()/IsInt64()/IsUint64()<sp/>也会返回<sp/>true</highlight></codeline>
<codeline><highlight class="normal">assert(document[&quot;i&quot;].IsInt());<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">printf(&quot;i<sp/>=<sp/>%d\n&quot;,<sp/>document[&quot;i&quot;].GetInt());</highlight></codeline>
<codeline><highlight class="normal">//<sp/>另一种用法：<sp/>(int)document[&quot;i&quot;]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">assert(document[&quot;pi&quot;].IsNumber());</highlight></codeline>
<codeline><highlight class="normal">assert(document[&quot;pi&quot;].IsDouble());</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;pi<sp/>=<sp/>%g\n&quot;,<sp/>document[&quot;pi&quot;].GetDouble());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">i<sp/>=<sp/>123</highlight></codeline>
<codeline><highlight class="normal">pi<sp/>=<sp/>3.1416</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">JSON<sp/>Array<sp/>包含一些元素。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>使用引用来连续访问，方便之余还更高效。</highlight></codeline>
<codeline><highlight class="normal">const<sp/>Value&amp;<sp/>a<sp/>=<sp/>document[&quot;a&quot;];</highlight></codeline>
<codeline><highlight class="normal">assert(a.IsArray());</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(SizeType<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>a.Size();<sp/>i++)<sp/>//<sp/>使用<sp/>SizeType<sp/>而不是<sp/>size_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;a[%d]<sp/>=<sp/>%d\n&quot;,<sp/>i,<sp/>a[i].GetInt());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">a[0]<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal">a[1]<sp/>=<sp/>2</highlight></codeline>
<codeline><highlight class="normal">a[2]<sp/>=<sp/>3</highlight></codeline>
<codeline><highlight class="normal">a[3]<sp/>=<sp/>4</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">注意，RapidJSON<sp/>并不自动转换各种<sp/>JSON<sp/>类型。例如，对一个<sp/>String<sp/>的<sp/>Value<sp/>调用<sp/>`GetInt()`<sp/>是非法的。在调试模式下，它会被断言失败。在发布模式下，其行为是未定义的。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">以下将会讨论有关查询各类型的细节。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>查询<sp/>Array<sp/>{#QueryArray}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">缺省情况下，`SizeType`<sp/>是<sp/>`unsigned`<sp/>的<sp/>typedef。在多数系统中，Array<sp/>最多能存储<sp/>2^32-1<sp/>个元素。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">你可以用整数字面量访问元素，如<sp/>`a[0]`、`a[1]`、`a[2]`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Array<sp/>与<sp/>`std::vector`<sp/>相似，除了使用索引，也可使用迭代器来访问所有元素。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(Value::ConstValueIterator<sp/>itr<sp/>=<sp/>a.Begin();<sp/>itr<sp/>!=<sp/>a.End();<sp/>++itr)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;%d<sp/>&quot;,<sp/>itr-&gt;GetInt());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">还有一些熟悉的查询函数：</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`SizeType<sp/>Capacity()<sp/>const`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`bool<sp/>Empty()<sp/>const`</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>范围<sp/>for<sp/>循环<sp/>(v1.1.0<sp/>中的新功能)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">当使用<sp/>C++11<sp/>功能时，你可使用范围<sp/>for<sp/>循环去访问<sp/>Array<sp/>内的所有元素。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(auto&amp;<sp/>v<sp/>:<sp/>a.GetArray())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;%d<sp/>&quot;,<sp/>v.GetInt());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>查询<sp/>Object<sp/>{#QueryObject}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">和<sp/>Array<sp/>相似，我们可以用迭代器去访问所有<sp/>Object<sp/>成员：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">static<sp/>const<sp/>char*<sp/>kTypeNames[]<sp/>=<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>&quot;Null&quot;,<sp/>&quot;False&quot;,<sp/>&quot;True&quot;,<sp/>&quot;Object&quot;,<sp/>&quot;Array&quot;,<sp/>&quot;String&quot;,<sp/>&quot;Number&quot;<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">for<sp/>(Value::ConstMemberIterator<sp/>itr<sp/>=<sp/>document.MemberBegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>itr<sp/>!=<sp/>document.MemberEnd();<sp/>++itr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Type<sp/>of<sp/>member<sp/>%s<sp/>is<sp/>%s\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr-&gt;name.GetString(),<sp/>kTypeNames[itr-&gt;value.GetType()]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>hello<sp/>is<sp/>String</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>t<sp/>is<sp/>True</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>f<sp/>is<sp/>False</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>n<sp/>is<sp/>Null</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>i<sp/>is<sp/>Number</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>pi<sp/>is<sp/>Number</highlight></codeline>
<codeline><highlight class="normal">Type<sp/>of<sp/>member<sp/>a<sp/>is<sp/>Array</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">注意，当<sp/>`operator[](const<sp/>char*)`<sp/>找不到成员，它会断言失败。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">若我们不确定一个成员是否存在，便需要在调用<sp/>`operator[](const<sp/>char*)`<sp/>前先调用<sp/>`HasMember()`。然而，这会导致两次查找。更好的做法是调用<sp/>`FindMember()`，它能同时检查成员是否存在并返回它的<sp/>Value：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value::ConstMemberIterator<sp/>itr<sp/>=<sp/>document.FindMember(&quot;hello&quot;);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(itr<sp/>!=<sp/>document.MemberEnd())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;%s\n&quot;,<sp/>itr-&gt;value.GetString());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>范围<sp/>for<sp/>循环<sp/>(v1.1.0<sp/>中的新功能)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">当使用<sp/>C++11<sp/>功能时，你可使用范围<sp/>for<sp/>循环去访问<sp/>Object<sp/>内的所有成员。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(auto&amp;<sp/>m<sp/>:<sp/>document.GetObject())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Type<sp/>of<sp/>member<sp/>%s<sp/>is<sp/>%s\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m.name.GetString(),<sp/>kTypeNames[m.value.GetType()]);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>查询<sp/>Number<sp/>{#QueryNumber}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">JSON<sp/>只提供一种数值类型──Number。数字可以是整数或实数。RFC<sp/>4627<sp/>规定数字的范围由解析器指定。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">由于<sp/>C++<sp/>提供多种整数及浮点数类型，DOM<sp/>尝试尽量提供最广的范围及良好性能。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">当解析一个<sp/>Number<sp/>时,<sp/>它会被存储在<sp/>DOM<sp/>之中，成为下列其中一个类型：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">类型<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>描述</highlight></codeline>
<codeline><highlight class="normal">-----------|---------------------------------------</highlight></codeline>
<codeline><highlight class="normal">`unsigned`<sp/>|<sp/>32<sp/>位无号整数</highlight></codeline>
<codeline><highlight class="normal">`int`<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>32<sp/>位有号整数</highlight></codeline>
<codeline><highlight class="normal">`uint64_t`<sp/>|<sp/>64<sp/>位无号整数</highlight></codeline>
<codeline><highlight class="normal">`int64_t`<sp/><sp/>|<sp/>64<sp/>位有号整数</highlight></codeline>
<codeline><highlight class="normal">`double`<sp/><sp/><sp/>|<sp/>64<sp/>位双精度浮点数</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">当查询一个<sp/>Number<sp/>时,<sp/>你可以检查该数字是否能以目标类型来提取：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">查检<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>提取</highlight></codeline>
<codeline><highlight class="normal">------------------|---------------------</highlight></codeline>
<codeline><highlight class="normal">`bool<sp/>IsNumber()`<sp/>|<sp/>不适用</highlight></codeline>
<codeline><highlight class="normal">`bool<sp/>IsUint()`<sp/><sp/><sp/>|<sp/>`unsigned<sp/>GetUint()`</highlight></codeline>
<codeline><highlight class="normal">`bool<sp/>IsInt()`<sp/><sp/><sp/><sp/>|<sp/>`int<sp/>GetInt()`</highlight></codeline>
<codeline><highlight class="normal">`bool<sp/>IsUint64()`<sp/>|<sp/>`uint64_t<sp/>GetUint64()`</highlight></codeline>
<codeline><highlight class="normal">`bool<sp/>IsInt64()`<sp/><sp/>|<sp/>`int64_t<sp/>GetInt64()`</highlight></codeline>
<codeline><highlight class="normal">`bool<sp/>IsDouble()`<sp/>|<sp/>`double<sp/>GetDouble()`</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">注意，一个整数可能用几种类型来提取，而无需转换。例如，一个名为<sp/>`x`<sp/>的<sp/>Value<sp/>包含<sp/>123，那么<sp/>`x.IsInt()<sp/>==<sp/>x.IsUint()<sp/>==<sp/>x.IsInt64()<sp/>==<sp/>x.IsUint64()<sp/>==<sp/>true`。但如果一个名为<sp/>`y`<sp/>的<sp/>Value<sp/>包含<sp/>-3000000000，那么仅会令<sp/>`x.IsInt64()<sp/>==<sp/>true`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">当要提取<sp/>Number<sp/>类型，`GetDouble()`<sp/>是会把内部整数的表示转换成<sp/>`double`。注意<sp/>`int`<sp/>和<sp/>`unsigned`<sp/>可以安全地转换至<sp/>`double`，但<sp/>`int64_t`<sp/>及<sp/>`uint64_t`<sp/>可能会丧失精度（因为<sp/>`double`<sp/>的尾数只有<sp/>52<sp/>位）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>查询<sp/>String<sp/>{#QueryString}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">除了<sp/>`GetString()`，`Value`<sp/>类也有一个<sp/>`GetStringLength()`。这里会解释个中原因。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">根据<sp/>RFC<sp/>4627，JSON<sp/>String<sp/>可包含<sp/>Unicode<sp/>字符<sp/>`U+0000`，在<sp/>JSON<sp/>中会表示为<sp/>`&quot;\u0000&quot;`。问题是，C/C++<sp/>通常使用空字符结尾字符串（null-terminated<sp/>string），这种字符串把<sp/>``\0&apos;`<sp/>作为结束符号。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">为了符合<sp/>RFC<sp/>4627，RapidJSON<sp/>支持包含<sp/>`U+0000`<sp/>的<sp/>String。若你需要处理这些<sp/>String，便可使用<sp/>`GetStringLength()`<sp/>去获得正确的字符串长度。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">例如，当解析以下的<sp/>JSON<sp/>至<sp/>`Document<sp/>d`<sp/>之后：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~js</highlight></codeline>
<codeline><highlight class="normal">{<sp/>&quot;s&quot;<sp/>:<sp/><sp/>&quot;a\u0000b&quot;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline><highlight class="normal">`&quot;a\u0000b&quot;`<sp/>值的正确长度应该是<sp/>3。但<sp/>`strlen()`<sp/>会返回<sp/>1。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`GetStringLength()`<sp/>也可以提高性能，因为用户可能需要调用<sp/>`strlen()`<sp/>去分配缓冲。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">此外，`std::string`<sp/>也支持这个构造函数：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">string(const<sp/>char*<sp/>s,<sp/>size_t<sp/>count);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">此构造函数接受字符串长度作为参数。它支持在字符串中存储空字符，也应该会有更好的性能。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>比较两个<sp/>Value</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">你可使用<sp/>`==`<sp/>及<sp/>`!=`<sp/>去比较两个<sp/>Value。当且仅当两个<sp/>Value<sp/>的类型及内容相同，它们才当作相等。你也可以比较<sp/>Value<sp/>和它的原生类型值。以下是一个例子。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(document[&quot;hello&quot;]<sp/>==<sp/>document[&quot;n&quot;])<sp/>/*...*/;<sp/><sp/><sp/><sp/>//<sp/>比较两个值</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(document[&quot;hello&quot;]<sp/>==<sp/>&quot;world&quot;)<sp/>/*...*/;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>与字符串字面量作比较</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(document[&quot;i&quot;]<sp/>!=<sp/>123)<sp/>/*...*/;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>与整数作比较</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(document[&quot;pi&quot;]<sp/>!=<sp/>3.14)<sp/>/*...*/;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>与<sp/>double<sp/>作比较</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Array／Object<sp/>顺序以它们的元素／成员作比较。当且仅当它们的整个子树相等，它们才当作相等。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">注意，现时若一个<sp/>Object<sp/>含有重复命名的成员，它与任何<sp/>Object<sp/>作比较都总会返回<sp/>`false`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>创建／修改值<sp/>{#CreateModifyValues}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">有多种方法去创建值。<sp/>当一个<sp/>DOM<sp/>树被创建或修改后，可使用<sp/>`Writer`<sp/>再次存储为<sp/>JSON。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>改变<sp/>Value<sp/>类型<sp/>{#ChangeValueType}</highlight></codeline>
<codeline><highlight class="normal">当使用默认构造函数创建一个<sp/>Value<sp/>或<sp/>Document，它的类型便会是<sp/>Null。要改变其类型，需调用<sp/>`SetXXX()`<sp/>或赋值操作，例如：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Document<sp/>d;<sp/>//<sp/>Null</highlight></codeline>
<codeline><highlight class="normal">d.SetObject();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Value<sp/>v;<sp/><sp/><sp/><sp/>//<sp/>Null</highlight></codeline>
<codeline><highlight class="normal">v.SetInt(10);</highlight></codeline>
<codeline><highlight class="normal">v<sp/>=<sp/>10;<sp/><sp/><sp/><sp/><sp/>//<sp/>简写，和上面的相同</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>构造函数的各个重载</highlight></codeline>
<codeline><highlight class="normal">几个类型也有重载构造函数：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>b(true);<sp/><sp/><sp/><sp/>//<sp/>调用<sp/>Value(bool)</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>i(-123);<sp/><sp/><sp/><sp/>//<sp/>调用<sp/>Value(int)</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>u(123u);<sp/><sp/><sp/><sp/>//<sp/>调用<sp/>Value(unsigned)</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>d(1.5);<sp/><sp/><sp/><sp/><sp/>//<sp/>调用<sp/>Value(double)</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">要重建空<sp/>Object<sp/>或<sp/>Array，可在默认构造函数后使用<sp/>`SetObject()`/`SetArray()`，或一次性使用<sp/>`Value(Type)`：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>o(kObjectType);</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>a(kArrayType);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>转移语义（Move<sp/>Semantics）<sp/>{#MoveSemantics}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">在设计<sp/>RapidJSON<sp/>时有一个非常特别的决定，就是<sp/>Value<sp/>赋值并不是把来源<sp/>Value<sp/>复制至目的<sp/>Value，而是把来源<sp/>Value<sp/>转移（move）至目的<sp/>Value。例如：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>a(123);</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>b(456);</highlight></codeline>
<codeline><highlight class="normal">b<sp/>=<sp/>a;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>a<sp/>变成<sp/>Null，b<sp/>变成数字<sp/>123。</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">![使用移动语义赋值。](diagram/move1.png)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">为什么？此语义有何优点？</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">最简单的答案就是性能。对于固定大小的<sp/>JSON<sp/>类型（Number、True、False、Null），复制它们是简单快捷。然而，对于可变大小的<sp/>JSON<sp/>类型（String、Array、Object），复制它们会产生大量开销，而且这些开销常常不被察觉。尤其是当我们需要创建临时<sp/>Object，把它复制至另一变量，然后再析构它。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">例如，若使用正常<sp/>*<sp/>复制<sp/>*<sp/>语义：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>o(kObjectType);</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Value<sp/>contacts(kArrayType);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>把元素加进<sp/>contacts<sp/>数组。</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>o.AddMember(&quot;contacts&quot;,<sp/>contacts,<sp/>d.GetAllocator());<sp/><sp/>//<sp/>深度复制<sp/>contacts<sp/>（可能有大量内存分配）</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>析构<sp/>contacts。</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">![复制语义产生大量的复制操作。](diagram/move2.png)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">那个<sp/>`o`<sp/>Object<sp/>需要分配一个和<sp/>contacts<sp/>相同大小的缓冲区，对<sp/>conacts<sp/>做深度复制，并最终要析构<sp/>contacts。这样会产生大量无必要的内存分配／释放，以及内存复制。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">有一些方案可避免实质地复制这些数据，例如引用计数（reference<sp/>counting）、垃圾回收（garbage<sp/>collection,<sp/>GC）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">为了使<sp/>RapidJSON<sp/>简单及快速，我们选择了对赋值采用<sp/>*<sp/>转移<sp/>*<sp/>语义。这方法与<sp/>`std::auto_ptr`<sp/>相似，都是在赋值时转移拥有权。转移快得多简单得多，只需要析构原来的<sp/>Value，把来源<sp/>`memcpy()`<sp/>至目标，最后把来源设置为<sp/>Null<sp/>类型。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">因此，使用转移语义后，上面的例子变成：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>o(kObjectType);</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Value<sp/>contacts(kArrayType);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>adding<sp/>elements<sp/>to<sp/>contacts<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>o.AddMember(&quot;contacts&quot;,<sp/>contacts,<sp/>d.GetAllocator());<sp/><sp/>//<sp/>只需<sp/>memcpy()<sp/>contacts<sp/>本身至新成员的<sp/>Value（16<sp/>字节）</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>contacts<sp/>在这里变成<sp/>Null。它的析构是平凡的。</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">![转移语义不需复制。](diagram/move3.png)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">在<sp/>C++11<sp/>中这称为转移赋值操作（move<sp/>assignment<sp/>operator）。由于<sp/>RapidJSON<sp/>支持<sp/>C++03，它在赋值操作采用转移语义，其它修改型函数如<sp/>`AddMember()`,<sp/>`PushBack()`<sp/>也采用转移语义。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>转移语义及临时值<sp/>{#TemporaryValues}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">有时候，我们想直接构造一个<sp/>Value<sp/>并传递给一个“转移”函数（如<sp/>`PushBack()`、`AddMember()`）。由于临时对象是不能转换为正常的<sp/>Value<sp/>引用，我们加入了一个方便的<sp/>`Move()`<sp/>函数：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>a(kArrayType);</highlight></codeline>
<codeline><highlight class="normal">Document::AllocatorType&amp;<sp/>allocator<sp/>=<sp/>document.GetAllocator();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>a.PushBack(Value(42),<sp/>allocator);<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>不能通过编译</highlight></codeline>
<codeline><highlight class="normal">a.PushBack(Value().SetInt(42),<sp/>allocator);<sp/>//<sp/>fluent<sp/>API</highlight></codeline>
<codeline><highlight class="normal">a.PushBack(Value(42).Move(),<sp/>allocator);<sp/><sp/><sp/>//<sp/>和上一行相同</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>创建<sp/>String<sp/>{#CreateString}</highlight></codeline>
<codeline><highlight class="normal">RapidJSON<sp/>提供两个<sp/>String<sp/>的存储策略。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>copy-string:<sp/>分配缓冲区，然后把来源数据复制至它。</highlight></codeline>
<codeline><highlight class="normal">2.<sp/>const-string:<sp/>简单地储存字符串的指针。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Copy-string<sp/>总是安全的，因为它拥有数据的克隆。Const-string<sp/>可用于存储字符串字面量，以及用于在<sp/>DOM<sp/>一节中将会提到的<sp/>in-situ<sp/>解析中。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">为了让用户自定义内存分配方式，当一个操作可能需要内存分配时，RapidJSON<sp/>要求用户传递一个<sp/>allocator<sp/>实例作为<sp/>API<sp/>参数。此设计避免了在每个<sp/>Value<sp/>存储<sp/>allocator（或<sp/>document）的指针。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">因此，当我们把一个<sp/>copy-string<sp/>赋值时,<sp/>调用含有<sp/>allocator<sp/>的<sp/>`SetString()`<sp/>重载函数：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Document<sp/>document;</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>author;</highlight></codeline>
<codeline><highlight class="normal">char<sp/>buffer[10];</highlight></codeline>
<codeline><highlight class="normal">int<sp/>len<sp/>=<sp/>sprintf(buffer,<sp/>&quot;%s<sp/>%s&quot;,<sp/>&quot;Milo&quot;,<sp/>&quot;Yip&quot;);<sp/>//<sp/>动态创建的字符串。</highlight></codeline>
<codeline><highlight class="normal">author.SetString(buffer,<sp/>len,<sp/>document.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal">memset(buffer,<sp/>0,<sp/>sizeof(buffer));</highlight></codeline>
<codeline><highlight class="normal">//<sp/>清空<sp/>buffer<sp/>后<sp/>author.GetString()<sp/>仍然包含<sp/>&quot;Milo<sp/>Yip&quot;</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">在此例子中，我们使用<sp/>`Document`<sp/>实例的<sp/>allocator。这是使用<sp/>RapidJSON<sp/>时常用的惯用法。但你也可以用其他<sp/>allocator<sp/>实例。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">另外，上面的<sp/>`SetString()`<sp/>需要长度参数。这个<sp/>API<sp/>能处理含有空字符的字符串。另一个<sp/>`SetString()`<sp/>重载函数没有长度参数，它假设输入是空字符结尾的，并会调用类似<sp/>`strlen()`<sp/>的函数去获取长度。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">最后，对于字符串字面量或有安全生命周期的字符串，可以使用<sp/>const-string<sp/>版本的<sp/>`SetString()`，它没有</highlight></codeline>
<codeline><highlight class="normal">allocator<sp/>参数。对于字符串字面量（或字符数组常量），只需简单地传递字面量，又安全又高效：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>s;</highlight></codeline>
<codeline><highlight class="normal">s.SetString(&quot;rapidjson&quot;);<sp/><sp/><sp/><sp/>//<sp/>可包含空字符，长度在编译期推导</highlight></codeline>
<codeline><highlight class="normal">s<sp/>=<sp/>&quot;rapidjson&quot;;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>上行的缩写</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">对于字符指针，RapidJSON<sp/>需要作一个标记，代表它不复制也是安全的。可以使用<sp/>`StringRef`<sp/>函数：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">const<sp/>char<sp/>*<sp/>cstr<sp/>=<sp/>getenv(&quot;USER&quot;);</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>cstr_len<sp/>=<sp/>...;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>如果有长度</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>s;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>s.SetString(cstr);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>这不能通过编译</highlight></codeline>
<codeline><highlight class="normal">s.SetString(StringRef(cstr));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>可以，假设它的生命周期安全，并且是以空字符结尾的</highlight></codeline>
<codeline><highlight class="normal">s<sp/>=<sp/>StringRef(cstr);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>上行的缩写</highlight></codeline>
<codeline><highlight class="normal">s.SetString(StringRef(cstr,<sp/>cstr_len));//<sp/>更快，可处理空字符</highlight></codeline>
<codeline><highlight class="normal">s<sp/>=<sp/>StringRef(cstr,<sp/>cstr_len);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>上行的缩写</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>修改<sp/>Array<sp/>{#ModifyArray}</highlight></codeline>
<codeline><highlight class="normal">Array<sp/>类型的<sp/>Value<sp/>提供与<sp/>`std::vector`<sp/>相似的<sp/>API。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/>`Clear()`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`Reserve(SizeType,<sp/>Allocator&amp;)`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`Value&amp;<sp/>PushBack(Value&amp;,<sp/>Allocator&amp;)`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`template<sp/>&lt;typename<sp/>T&gt;<sp/>GenericValue&amp;<sp/>PushBack(T,<sp/>Allocator&amp;)`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`Value&amp;<sp/>PopBack()`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`ValueIterator<sp/>Erase(ConstValueIterator<sp/>pos)`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`ValueIterator<sp/>Erase(ConstValueIterator<sp/>first,<sp/>ConstValueIterator<sp/>last)`</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">注意，`Reserve(...)`<sp/>及<sp/>`PushBack(...)`<sp/>可能会为数组元素分配内存，所以需要一个<sp/>allocator。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">以下是<sp/>`PushBack()`<sp/>的例子：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>a(kArrayType);</highlight></codeline>
<codeline><highlight class="normal">Document::AllocatorType&amp;<sp/>allocator<sp/>=<sp/>document.GetAllocator();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">for<sp/>(int<sp/>i<sp/>=<sp/>5;<sp/>i<sp/>&lt;=<sp/>10;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>a.PushBack(i,<sp/>allocator);<sp/><sp/><sp/>//<sp/>可能需要调用<sp/>realloc()<sp/>所以需要<sp/>allocator</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>流畅接口（Fluent<sp/>interface）</highlight></codeline>
<codeline><highlight class="normal">a.PushBack(&quot;Lua&quot;,<sp/>allocator).PushBack(&quot;Mio&quot;,<sp/>allocator);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">与<sp/>STL<sp/>不一样的是，`PushBack()`/`PopBack()`<sp/>返回<sp/>Array<sp/>本身的引用。这称为流畅接口（_fluent<sp/>interface_）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">如果你想在<sp/>Array<sp/>中加入一个非常量字符串，或是一个没有足够生命周期的字符串（见<sp/>[Create<sp/>String](#CreateString)），你需要使用<sp/>copy-string<sp/>API<sp/>去创建一个<sp/>String。为了避免加入中间变量，可以就地使用一个<sp/>[临时值](#TemporaryValues)：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>就地<sp/>Value<sp/>参数</highlight></codeline>
<codeline><highlight class="normal">contact.PushBack(Value(&quot;copy&quot;,<sp/>document.GetAllocator()).Move(),<sp/>//<sp/>copy<sp/>string</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>document.GetAllocator());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>显式<sp/>Value<sp/>参数</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>val(&quot;key&quot;,<sp/>document.GetAllocator());<sp/>//<sp/>copy<sp/>string</highlight></codeline>
<codeline><highlight class="normal">contact.PushBack(val,<sp/>document.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>修改<sp/>Object<sp/>{#ModifyObject}</highlight></codeline>
<codeline><highlight class="normal">Object<sp/>是键值对的集合。每个键必须为<sp/>String。要修改<sp/>Object，方法是增加或移除成员。以下的<sp/>API<sp/>用来增加成员：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/>`Value&amp;<sp/>AddMember(Value&amp;,<sp/>Value&amp;,<sp/>Allocator&amp;<sp/>allocator)`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`Value&amp;<sp/>AddMember(StringRefType,<sp/>Value&amp;,<sp/>Allocator&amp;)`</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`template<sp/>&lt;typename<sp/>T&gt;<sp/>Value&amp;<sp/>AddMember(StringRefType,<sp/>T<sp/>value,<sp/>Allocator&amp;)`</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">以下是一个例子。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>contact(kObject);</highlight></codeline>
<codeline><highlight class="normal">contact.AddMember(&quot;name&quot;,<sp/>&quot;Milo&quot;,<sp/>document.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal">contact.AddMember(&quot;married&quot;,<sp/>true,<sp/>document.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">使用<sp/>`StringRefType`<sp/>作为<sp/>name<sp/>参数的重载版本与字符串的<sp/>`SetString`<sp/>的接口相似。<sp/>这些重载是为了避免复制<sp/>`name`<sp/>字符串，因为<sp/>JSON<sp/>object<sp/>中经常会使用常数键名。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">如果你需要从非常数字符串或生命周期不足的字符串创建键名（见<sp/>[创建<sp/>String](#CreateString)），你需要使用<sp/>copy-string<sp/>API。为了避免中间变量，可以就地使用<sp/>[临时值](#TemporaryValues)：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>就地<sp/>Value<sp/>参数</highlight></codeline>
<codeline><highlight class="normal">contact.AddMember(Value(&quot;copy&quot;,<sp/>document.GetAllocator()).Move(),<sp/>//<sp/>copy<sp/>string</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Value().Move(),<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>null<sp/>value</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>document.GetAllocator());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>显式参数</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>key(&quot;key&quot;,<sp/>document.GetAllocator());<sp/>//<sp/>copy<sp/>string<sp/>name</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>val(42);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>某<sp/>Value</highlight></codeline>
<codeline><highlight class="normal">contact.AddMember(key,<sp/>val,<sp/>document.GetAllocator());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">移除成员有几个选择：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/>`bool<sp/>RemoveMember(const<sp/>Ch*<sp/>name)`：使用键名来移除成员（线性时间复杂度）。</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`bool<sp/>RemoveMember(const<sp/>Value&amp;<sp/>name)`：除了<sp/>`name`<sp/>是一个<sp/>Value，和上一行相同。</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`MemberIterator<sp/>RemoveMember(MemberIterator)`：使用迭代器移除成员（_<sp/>常数<sp/>_<sp/>时间复杂度）。</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`MemberIterator<sp/>EraseMember(MemberIterator)`：和上行相似但维持成员次序（线性时间复杂度）。</highlight></codeline>
<codeline><highlight class="normal">*<sp/>`MemberIterator<sp/>EraseMember(MemberIterator<sp/>first,<sp/>MemberIterator<sp/>last)`：移除一个范围内的成员，维持次序（线性时间复杂度）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`MemberIterator<sp/>RemoveMember(MemberIterator)`<sp/>使用了“转移最后”手法来达成常数时间复杂度。基本上就是析构迭代器位置的成员，然后把最后的成员转移至迭代器位置。因此，成员的次序会被改变。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>深复制<sp/>Value<sp/>{#DeepCopyValue}</highlight></codeline>
<codeline><highlight class="normal">若我们真的要复制一个<sp/>DOM<sp/>树，我们可使用两个<sp/>APIs<sp/>作深复制：含<sp/>allocator<sp/>的构造函数及<sp/>`CopyFrom()`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Document<sp/>d;</highlight></codeline>
<codeline><highlight class="normal">Document::AllocatorType&amp;<sp/>a<sp/>=<sp/>d.GetAllocator();</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>v1(&quot;foo&quot;);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Value<sp/>v2(v1);<sp/>//<sp/>不容许</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Value<sp/>v2(v1,<sp/>a);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>制造一个克隆</highlight></codeline>
<codeline><highlight class="normal">assert(v1.IsString());<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>v1<sp/>不变</highlight></codeline>
<codeline><highlight class="normal">d.SetArray().PushBack(v1,<sp/>a).PushBack(v2,<sp/>a);</highlight></codeline>
<codeline><highlight class="normal">assert(v1.IsNull()<sp/>&amp;&amp;<sp/>v2.IsNull());<sp/><sp/><sp/>//<sp/>两个都转移动<sp/>d</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">v2.CopyFrom(d,<sp/>a);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>把整个<sp/>document<sp/>复制至<sp/>v2</highlight></codeline>
<codeline><highlight class="normal">assert(d.IsArray()<sp/>&amp;&amp;<sp/>d.Size()<sp/>==<sp/>2);<sp/>//<sp/>d<sp/>不变</highlight></codeline>
<codeline><highlight class="normal">v1.SetObject().AddMember(&quot;array&quot;,<sp/>v2,<sp/>a);</highlight></codeline>
<codeline><highlight class="normal">d.PushBack(v1,<sp/>a);</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>交换<sp/>Value<sp/>{#SwapValues}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">RapidJSON<sp/>也提供<sp/>`Swap()`。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">~~~~~~~~~~cpp</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>a(123);</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>b(&quot;Hello&quot;);</highlight></codeline>
<codeline><highlight class="normal">a.Swap(b);</highlight></codeline>
<codeline><highlight class="normal">assert(a.IsString());</highlight></codeline>
<codeline><highlight class="normal">assert(b.IsInt());</highlight></codeline>
<codeline><highlight class="normal">~~~~~~~~~~</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">无论两棵<sp/>DOM<sp/>树有多复杂，交换是很快的（常数时间）。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>下一部分<sp/>{#WhatsNext}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">本教程展示了如何询查及修改<sp/>DOM<sp/>树。RapidJSON<sp/>还有一个重要概念：</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>[流](doc/stream.zh-cn.md)<sp/>是读写<sp/>JSON<sp/>的通道。流可以是内存字符串、文件流等。用户也可以自定义流。</highlight></codeline>
<codeline><highlight class="normal">2.<sp/>[编码](doc/encoding.zh-cn.md)<sp/>定义在流或内存中使用的字符编码。RapidJSON<sp/>也在内部提供<sp/>Unicode<sp/>转换及校验功能。</highlight></codeline>
<codeline><highlight class="normal">3.<sp/>[DOM](doc/dom.zh-cn.md)<sp/>的基本功能已在本教程里介绍。还有更高级的功能，如原位（*in<sp/>situ*）解析、其他解析选项及高级用法。</highlight></codeline>
<codeline><highlight class="normal">4.<sp/>[SAX](doc/sax.zh-cn.md)<sp/>是<sp/>RapidJSON<sp/>解析／生成功能的基础。学习使用<sp/>`Reader`/`Writer`<sp/>去实现更高性能的应用程序。也可以使用<sp/>`PrettyWriter`<sp/>去格式化<sp/>JSON。</highlight></codeline>
<codeline><highlight class="normal">5.<sp/>[性能](doc/performance.zh-cn.md)<sp/>展示一些我们做的及第三方的性能测试。</highlight></codeline>
<codeline><highlight class="normal">6.<sp/>[技术内幕](doc/internals.md)<sp/>讲述一些<sp/>RapidJSON<sp/>内部的设计及技术。</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">你也可以参考<sp/>[常见问题](doc/faq.zh-cn.md)、API<sp/>文档、例子及单元测试。</highlight></codeline>
    </programlisting>
    <location file="src/rapidjson/doc/tutorial.zh-cn.md"/>
  </compounddef>
</doxygen>
