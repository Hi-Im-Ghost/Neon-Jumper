\char`\"{}\+SAX\char`\"{} 此术语源于 \href{http://en.wikipedia.org/wiki/Simple_API_for_XML}{\texttt{ Simple API for XML}}。我们借了此术语去套用在 JSON 的解析及生成。

在 Rapid\+JSON 中，{\ttfamily Reader}（{\ttfamily \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} 的 typedef）是 JSON 的 SAX 风格解析器，而 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}}（{\ttfamily Generic\+Writer\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} 的 typedef）则是 JSON 的 SAX 风格生成器。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_Reader}{}\doxysection{Reader}\label{md_src_rapidjson_doc_sax_zh_cn_Reader}
{\ttfamily Reader} 从输入流解析一个 JSON。当它从流中读取字符时，它会基于 JSON 的语法去分析字符，并向处理器发送事件。

例如，以下是一个 JSON。


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{    "{}hello"{}: "{}world"{},}
\DoxyCodeLine{    "{}t"{}: true ,}
\DoxyCodeLine{    "{}f"{}: false,}
\DoxyCodeLine{    "{}n"{}: null,}
\DoxyCodeLine{    "{}i"{}: 123,}
\DoxyCodeLine{    "{}pi"{}: 3.1416,}
\DoxyCodeLine{    "{}a"{}: [1, 2, 3, 4]}
\DoxyCodeLine{\}}

\end{DoxyCode}


当一个 {\ttfamily Reader} 解析此 JSON 时，它会顺序地向处理器发送以下的事件：


\begin{DoxyCode}{0}
\DoxyCodeLine{StartObject()}
\DoxyCodeLine{Key("{}hello"{}, 5, true)}
\DoxyCodeLine{String("{}world"{}, 5, true)}
\DoxyCodeLine{Key("{}t"{}, 1, true)}
\DoxyCodeLine{Bool(true)}
\DoxyCodeLine{Key("{}f"{}, 1, true)}
\DoxyCodeLine{Bool(false)}
\DoxyCodeLine{Key("{}n"{}, 1, true)}
\DoxyCodeLine{Null()}
\DoxyCodeLine{Key("{}i"{})}
\DoxyCodeLine{Uint(123)}
\DoxyCodeLine{Key("{}pi"{})}
\DoxyCodeLine{Double(3.1416)}
\DoxyCodeLine{Key("{}a"{})}
\DoxyCodeLine{StartArray()}
\DoxyCodeLine{Uint(1)}
\DoxyCodeLine{Uint(2)}
\DoxyCodeLine{Uint(3)}
\DoxyCodeLine{Uint(4)}
\DoxyCodeLine{EndArray(4)}
\DoxyCodeLine{EndObject(7)}

\end{DoxyCode}


除了一些事件参数需要再作解释，这些事件可以轻松地与 JSON 对上。我们可以看看 {\ttfamily simplereader} 例子怎样产生和以上完全相同的结果：


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{reader_8h}{rapidjson/reader.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespacerapidjson}{rapidjson}};}
\DoxyCodeLine{\textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{struct_my_handler}{MyHandler}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_base_reader_handler}{BaseReaderHandler}}<UTF8<>, MyHandler> \{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a73b14891ee0ab44fc336b3e2044e3153}{Null}}() \{ cout << \textcolor{stringliteral}{"{}Null()"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a29eeca8918d0966a0551adb23c8a2b15}{Bool}}(\textcolor{keywordtype}{bool} b) \{ cout << \textcolor{stringliteral}{"{}Bool("{}} << boolalpha << b << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_aa7cda8307f15dd8f4a09947e527d56cf}{Int}}(\textcolor{keywordtype}{int} i) \{ cout << \textcolor{stringliteral}{"{}Int("{}} << i << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a469684e51df996bab87e0c22c0ea64fd}{Uint}}(\textcolor{keywordtype}{unsigned} u) \{ cout << \textcolor{stringliteral}{"{}Uint("{}} << u << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a5676446b090d3c71386aec6a39dbb188}{Int64}}(\mbox{\hyperlink{stdint_8h_a414156feea104f8f75b4ed9e3121b2f6}{int64\_t}} i) \{ cout << \textcolor{stringliteral}{"{}Int64("{}} << i << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a87b2d8341b4e3a38d405a89fe0d848ad}{Uint64}}(\mbox{\hyperlink{stdint_8h_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}} u) \{ cout << \textcolor{stringliteral}{"{}Uint64("{}} << u << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a5ff39ea10f682eab1943480b020c6f5a}{Double}}(\textcolor{keywordtype}{double} d) \{ cout << \textcolor{stringliteral}{"{}Double("{}} << d << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a5f46e8498869668d70e23453126a7b12}{String}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy) \{ }
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"{}String("{}} << str << \textcolor{stringliteral}{"{}, "{}} << length << \textcolor{stringliteral}{"{}, "{}} << boolalpha << copy << \textcolor{stringliteral}{"{})"{}} << endl;}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_afc0da4321f0a06e3cd351e573c435ffe}{StartObject}}() \{ cout << \textcolor{stringliteral}{"{}StartObject()"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_afca1a3a16289baf03128fa7d63081526}{Key}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy) \{ }
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"{}Key("{}} << str << \textcolor{stringliteral}{"{}, "{}} << length << \textcolor{stringliteral}{"{}, "{}} << boolalpha << copy << \textcolor{stringliteral}{"{})"{}} << endl;}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a3eb4011dcba95939e5f08e71c1596395}{EndObject}}(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} memberCount) \{ cout << \textcolor{stringliteral}{"{}EndObject("{}} << memberCount << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a1e794a6439658520bda0de14f661fc50}{StartArray}}() \{ cout << \textcolor{stringliteral}{"{}StartArray()"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_my_handler_a8654e16efc52d41397ce1a9af98bcb80}{EndArray}}(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} elementCount) \{ cout << \textcolor{stringliteral}{"{}EndArray("{}} << elementCount << \textcolor{stringliteral}{"{})"{}} << endl; \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{_c_make_c_compiler_id_8c_a0ddf1224851353fc92bfbff6f499fa97}{main}}() \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{char} json[] = \textcolor{stringliteral}{"{} \{ \(\backslash\)"{}hello\(\backslash\)"{} : \(\backslash\)"{}world\(\backslash\)"{}, \(\backslash\)"{}t\(\backslash\)"{} : true , \(\backslash\)"{}f\(\backslash\)"{} : false, \(\backslash\)"{}n\(\backslash\)"{}: null, \(\backslash\)"{}i\(\backslash\)"{}:123, \(\backslash\)"{}pi\(\backslash\)"{}: 3.1416, \(\backslash\)"{}a\(\backslash\)"{}:[1, 2, 3, 4] \} "{}};}
\DoxyCodeLine{}
\DoxyCodeLine{    \mbox{\hyperlink{struct_my_handler}{MyHandler}} handler;}
\DoxyCodeLine{    \mbox{\hyperlink{class_generic_reader}{Reader}} reader;}
\DoxyCodeLine{    \mbox{\hyperlink{struct_generic_string_stream}{StringStream}} ss(json);}
\DoxyCodeLine{    reader.\mbox{\hyperlink{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}{Parse}}(ss, handler);}
\DoxyCodeLine{\}}

\end{DoxyCode}


注意 Rapid\+JSON 使用模板去静态挷定 {\ttfamily Reader} 类型及处理器的类型，而不是使用含虚函数的类。这个范式可以通过把函数内联而改善性能。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_Handler}{}\doxysubsection{Handler}\label{md_src_rapidjson_doc_sax_zh_cn_Handler}
如前例所示，使用者需要实现一个处理器（handler），用于处理来自 {\ttfamily Reader} 的事件（函数调用）。处理器必须包含以下的成员函数。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Null();}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Bool(\textcolor{keywordtype}{bool} b);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Int(\textcolor{keywordtype}{int} i);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Uint(\textcolor{keywordtype}{unsigned} i);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Int64(\mbox{\hyperlink{stdint_8h_a414156feea104f8f75b4ed9e3121b2f6}{int64\_t}} i);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Uint64(\mbox{\hyperlink{stdint_8h_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}} i);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Double(\textcolor{keywordtype}{double} d);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} RawNumber(\textcolor{keyword}{const} Ch* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} String(\textcolor{keyword}{const} Ch* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} StartObject();}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} Key(\textcolor{keyword}{const} Ch* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} EndObject(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} memberCount);}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} StartArray();}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} EndArray(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} elementCount);}
\DoxyCodeLine{\};}

\end{DoxyCode}


当 {\ttfamily Reader} 遇到 JSON null 值时会调用 {\ttfamily Null()}。

当 {\ttfamily Reader} 遇到 JSON true 或 false 值时会调用 {\ttfamily Bool(bool)}。

当 {\ttfamily Reader} 遇到 JSON number，它会选择一个合适的 C++ 类型映射，然后调用 {\ttfamily Int(int)}、{\ttfamily Uint(unsigned)}、{\ttfamily Int64(int64\+\_\+t)}、{\ttfamily Uint64(uint64\+\_\+t)} 及 {\ttfamily Double(double)} 的 $\ast$ 其中之一个 $\ast$。 若开启了 {\ttfamily k\+Parse\+Numbers\+As\+Strings} 选项，{\ttfamily Reader} 便会改为调用 {\ttfamily Raw\+Number()}。

当 {\ttfamily Reader} 遇到 JSON string，它会调用 {\ttfamily String(const char$\ast$ str, Size\+Type length, bool copy)}。第一个参数是字符串的指针。第二个参数是字符串的长度（不包含空终止符号）。注意 Rapid\+JSON 支持字串中含有空字符 {\ttfamily \textbackslash{}0}。若出现这种情况，便会有 {\ttfamily strlen(str) \texorpdfstring{$<$}{<} length}。最后的 {\ttfamily copy} 参数表示处理器是否需要复制该字符串。在正常解析时，{\ttfamily copy = true}。仅当使用原位解析时，{\ttfamily copy = false}。此外，还要注意字符的类型与目标编码相关，我们稍后会再谈这一点。

当 {\ttfamily Reader} 遇到 JSON object 的开始之时，它会调用 {\ttfamily Start\+Object()}。\+JSON 的 object 是一个键值对（成员）的集合。若 object 包含成员，它会先为成员的名字调用 {\ttfamily Key()}，然后再按值的类型调用函数。它不断调用这些键值对，直至最终调用 {\ttfamily End\+Object(\+Size\+Type member\+Count)}。注意 {\ttfamily member\+Count} 参数对处理器来说只是协助性质，使用者可能不需要此参数。

JSON array 与 object 相似，但更简单。在 array 开始时，{\ttfamily Reader} 会调用 {\ttfamily Begin\+Arary()}。若 array 含有元素，它会按元素的类型来读用函数。相似地，最后它会调用 {\ttfamily End\+Array(\+Size\+Type element\+Count)}，其中 {\ttfamily element\+Count} 参数对处理器来说只是协助性质。

每个处理器函数都返回一个 {\ttfamily bool}。正常它们应返回 {\ttfamily true}。若处理器遇到错误，它可以返回 {\ttfamily false} 去通知事件发送方停止继续处理。

例如，当我们用 {\ttfamily Reader} 解析一个 JSON 时，处理器检测到该 JSON 并不符合所需的 schema，那么处理器可以返回 {\ttfamily false}，令 {\ttfamily Reader} 停止之后的解析工作。而 {\ttfamily Reader} 会进入一个错误状态，并以 {\ttfamily k\+Parse\+Error\+Termination} 错误码标识。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_GenericReader}{}\doxysubsection{Generic\+Reader}\label{md_src_rapidjson_doc_sax_zh_cn_GenericReader}
前面提及，{\ttfamily Reader} 是 {\ttfamily \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}} 模板类的 typedef：


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespacerapidjson}{rapidjson}} \{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} SourceEncoding, \textcolor{keyword}{typename} TargetEncoding, \textcolor{keyword}{typename} Allocator = MemoryPoolAllocator<> >}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{class_generic_reader}{GenericReader}} \{}
\DoxyCodeLine{    \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_generic_reader}{GenericReader<UTF8<>}}, \mbox{\hyperlink{struct_u_t_f8}{UTF8<>}} > \mbox{\hyperlink{fwd_8h_ab7f1c1207749ff25c0d7f0cc88e62788}{Reader}};}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// namespace rapidjson}}

\end{DoxyCode}


{\ttfamily Reader} 使用 UTF-\/8 作为来源及目标编码。来源编码是指 JSON 流的编码。目标编码是指 {\ttfamily String()} 的 {\ttfamily str} 参数所用的编码。例如，要解析一个 UTF-\/8 流并输出至 UTF-\/16 string 事件，你需要这么定义一个 reader：


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_reader}{GenericReader<UTF8<>}}, \mbox{\hyperlink{struct_u_t_f16}{UTF16<>}} > reader;}

\end{DoxyCode}


注意到 {\ttfamily \mbox{\hyperlink{struct_u_t_f16}{UTF16}}} 的缺省类型是 {\ttfamily wchar\+\_\+t}。因此这个 {\ttfamily reader} 需要调用处理器的 {\ttfamily String(const wchar\+\_\+t$\ast$, Size\+Type, bool)}。

第三个模板参数 {\ttfamily Allocator} 是内部数据结构（实际上是一个堆栈）的分配器类型。\hypertarget{md_src_rapidjson_doc_schema_zh_cn_SaxParsing}{}\doxysubsection{Parsing}\label{md_src_rapidjson_doc_schema_zh_cn_SaxParsing}
{\ttfamily Reader} 的唯一功能就是解析 JSON。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} parseFlags, \textcolor{keyword}{typename} InputStream, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} Parse(InputStream\& is, \mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}}\& handler);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// 使用 parseFlags = kDefaultParseFlags}}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} InputStream, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} Parse(InputStream\& is, \mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}}\& handler);}

\end{DoxyCode}


若在解析中出现错误，它会返回 {\ttfamily false}。使用者可调用 {\ttfamily bool Has\+Parse\+Eror()}, {\ttfamily Parse\+Error\+Code Get\+Parse\+Error\+Code()} 及 {\ttfamily size\+\_\+t Get\+Error\+Offset()} 获取错误状态。实际上 {\ttfamily Document} 使用这些 {\ttfamily Reader} 函数去获取解析错误。请参考 \mbox{\hyperlink{dom_8zh-cn_8md}{DOM}} 去了解有关解析错误的细节。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_Writer}{}\doxysection{Writer}\label{md_src_rapidjson_doc_sax_zh_cn_Writer}
{\ttfamily Reader} 把 JSON 转换（解析）成为事件。{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 做完全相反的事情。它把事件转换成 JSON。

{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 是非常容易使用的。若你的应用程序只需把一些数据转换成 JSON，可能直接使用 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}}，会比建立一个 {\ttfamily Document} 然后用 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 把它转换成 JSON 更加方便。

在 {\ttfamily simplewriter} 例子里，我们做 {\ttfamily simplereader} 完全相反的事情。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{writer_8h}{rapidjson/writer.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{stringbuffer_8h}{rapidjson/stringbuffer.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespacerapidjson}{rapidjson}};}
\DoxyCodeLine{\textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{_c_make_c_compiler_id_8c_a0ddf1224851353fc92bfbff6f499fa97}{main}}() \{}
\DoxyCodeLine{    \mbox{\hyperlink{class_generic_string_buffer}{StringBuffer}} s;}
\DoxyCodeLine{    \mbox{\hyperlink{class_writer}{Writer<StringBuffer>}} writer(s);}
\DoxyCodeLine{    }
\DoxyCodeLine{    writer.StartObject();}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}hello"{}});}
\DoxyCodeLine{    writer.String(\textcolor{stringliteral}{"{}world"{}});}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}t"{}});}
\DoxyCodeLine{    writer.Bool(\textcolor{keyword}{true});}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}f"{}});}
\DoxyCodeLine{    writer.Bool(\textcolor{keyword}{false});}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}n"{}});}
\DoxyCodeLine{    writer.Null();}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}i"{}});}
\DoxyCodeLine{    writer.Uint(123);}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}pi"{}});}
\DoxyCodeLine{    writer.Double(3.1416);}
\DoxyCodeLine{    writer.Key(\textcolor{stringliteral}{"{}a"{}});}
\DoxyCodeLine{    writer.StartArray();}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < 4; i++)}
\DoxyCodeLine{        writer.Uint(i);}
\DoxyCodeLine{    writer.EndArray();}
\DoxyCodeLine{    writer.EndObject();}
\DoxyCodeLine{}
\DoxyCodeLine{    cout << s.\mbox{\hyperlink{class_generic_string_buffer_a42079865bab1deb930c6cff7d491c719}{GetString}}() << endl;}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}hello"{}:"{}world"{},"{}t"{}:true,"{}f"{}:false,"{}n"{}:null,"{}i"{}:123,"{}pi"{}:3.1416,"{}a"{}:[0,1,2,3]\}}

\end{DoxyCode}


{\ttfamily String()} 及 {\ttfamily Key()} 各有两个重载。一个是如处理器 concept 般，有 3 个参数。它能处理含空字符的字符串。另一个是如上中使用的较简单版本。

注意到，例子代码中的 {\ttfamily End\+Array()} 及 {\ttfamily End\+Object()} 并没有参数。可以传递一个 {\ttfamily Size\+Type} 的参数，但它会被 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 忽略。

你可能会怀疑，为什么不使用 {\ttfamily sprintf()} 或 {\ttfamily std\+::stringstream} 去建立一个 JSON？

这有几个原因：
\begin{DoxyEnumerate}
\item {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 必然会输出一个结构良好（well-\/formed）的 JSON。若然有错误的事件次序（如 {\ttfamily Int()} 紧随 {\ttfamily Start\+Object()} 出现），它会在调试模式中产生断言失败。
\item {\ttfamily \mbox{\hyperlink{class_writer_a8b4dc44f471403a83c9959575796ceab}{Writer\+::\+String()}}} 可处理字符串转义（如把码点 {\ttfamily U+000A} 转换成 {\ttfamily \textbackslash{}n}）及进行 Unicode 转码。
\item {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 一致地处理 number 的输出。
\item {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 实现了事件处理器 concept。可用于处理来自 {\ttfamily Reader}、{\ttfamily Document} 或其他事件发生器。
\item {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 可对不同平台进行优化。
\end{DoxyEnumerate}

无论如何，使用 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} API 去生成 JSON 甚至乎比这些临时方法更简单。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_WriterTemplate}{}\doxysubsection{Template}\label{md_src_rapidjson_doc_sax_zh_cn_WriterTemplate}
{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 与 {\ttfamily Reader} 有少许设计区别。{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 是一个模板类，而不是一个 typedef。 并没有 {\ttfamily Generic\+Writer}。以下是 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 的声明。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespacerapidjson}{rapidjson}} \{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OutputStream, \textcolor{keyword}{typename} SourceEncoding = UTF8<>, \textcolor{keyword}{typename} TargetEncoding = UTF8<>, \textcolor{keyword}{typename} Allocator = CrtAllocator<> >}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{class_writer}{Writer}} \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{    \mbox{\hyperlink{class_writer}{Writer}}(OutputStream\& os, \mbox{\hyperlink{classrapidjson_1_1_allocator}{Allocator}}* allocator = 0, \textcolor{keywordtype}{size\_t} levelDepth = kDefaultLevelDepth)}
\DoxyCodeLine{\textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// namespace rapidjson}}

\end{DoxyCode}


{\ttfamily Output\+Stream} 模板参数是输出流的类型。它的类型不可以被自动推断，必须由使用者提供。

{\ttfamily Source\+Encoding} 模板参数指定了 {\ttfamily String(const Ch$\ast$, ...)} 的编码。

{\ttfamily Target\+Encoding} 模板参数指定输出流的编码。

{\ttfamily Allocator} 是分配器的类型，用于分配内部数据结构（一个堆栈）。

{\ttfamily write\+Flags} 是以下位标志的组合：

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 写入位标志   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 意义    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 写入位标志   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 意义    }\\\cline{1-2}
\endhead
{\ttfamily k\+Write\+No\+Flags}   &没有任何标志。    \\\cline{1-2}
{\ttfamily k\+Write\+Default\+Flags}   &缺省的解析选项。它等于 {\ttfamily RAPIDJSON\+\_\+\+WRITE\+\_\+\+DEFAULT\+\_\+\+FLAGS} 宏，此宏定义为 {\ttfamily k\+Write\+No\+Flags}。    \\\cline{1-2}
{\ttfamily k\+Write\+Validate\+Encoding\+Flag}   &校验 JSON 字符串的编码。    \\\cline{1-2}
{\ttfamily k\+Write\+Nan\+And\+Inf\+Flag}   &容许写入 {\ttfamily Infinity}, {\ttfamily -\/Infinity} 及 {\ttfamily NaN}。   \\\cline{1-2}
\end{longtabu}


此外，{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 的构造函数有一 {\ttfamily level\+Depth} 参数。存储每层阶信息的初始内存分配量受此参数影响。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_PrettyWriter}{}\doxysubsection{Pretty\+Writer}\label{md_src_rapidjson_doc_sax_zh_cn_PrettyWriter}
{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 所输出的是没有空格字符的最紧凑 JSON，适合网络传输或储存，但不适合人类阅读。

因此，\+Rapid\+JSON 提供了一个 {\ttfamily \mbox{\hyperlink{class_pretty_writer}{Pretty\+Writer}}}，它在输出中加入缩进及换行。

{\ttfamily \mbox{\hyperlink{class_pretty_writer}{Pretty\+Writer}}} 的用法与 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 几乎一样，不同之处是 {\ttfamily \mbox{\hyperlink{class_pretty_writer}{Pretty\+Writer}}} 提供了一个 {\ttfamily Set\+Indent(\+Ch indent\+Char, unsigned indent\+Char\+Count)} 函数。缺省的缩进是 4 个空格。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_CompletenessReset}{}\doxysubsection{Completeness and Reset}\label{md_src_rapidjson_doc_sax_zh_cn_CompletenessReset}
一个 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 只可输出单个 JSON，其根节点可以是任何 JSON 类型。当处理完单个根节点事件（如 {\ttfamily String()}），或匹配的最后 {\ttfamily End\+Object()} 或 {\ttfamily End\+Array()} 事件，输出的 JSON 是结构完整（well-\/formed）及完整的。使用者可调用 {\ttfamily \mbox{\hyperlink{class_writer_a07d74d36dd3191b06e0aab678c246157}{Writer\+::\+Is\+Complete()}}} 去检测完整性。

当 JSON 完整时，{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 不能再接受新的事件。不然其输出便会是不合法的（例如有超过一个根节点）。为了重新利用 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 对象，使用者可调用 {\ttfamily \mbox{\hyperlink{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}{Writer\+::\+Reset(\+Output\+Stream\& os)}}} 去重置其所有内部状态及设置新的输出流。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_SaxTechniques}{}\doxysection{Techniques}\label{md_src_rapidjson_doc_sax_zh_cn_SaxTechniques}
\hypertarget{md_src_rapidjson_doc_sax_zh_cn_CustomDataStructure}{}\doxysubsection{Parsing JSON to Custom Data Structure}\label{md_src_rapidjson_doc_sax_zh_cn_CustomDataStructure}
{\ttfamily Document} 的解析功能完全依靠 {\ttfamily Reader}。实际上 {\ttfamily Document} 是一个处理器，在解析 JSON 时接收事件去建立一个 DOM。

使用者可以直接使用 {\ttfamily Reader} 去建立其他数据结构。这消除了建立 DOM 的步骤，从而减少了内存开销并改善性能。

在以下的 {\ttfamily messagereader} 例子中，{\ttfamily Parse\+Messages()} 解析一个 JSON，该 JSON 应该是一个含键值对的 object。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{reader_8h}{rapidjson/reader.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{en_8h}{rapidjson/error/en.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespacerapidjson}{rapidjson}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{typedef} map<string, string> \mbox{\hyperlink{messagereader_8cpp_ae2c5980b5eb04369faa7f72447e6d664}{MessageMap}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{struct_message_handler}{MessageHandler}}}
\DoxyCodeLine{    : \textcolor{keyword}{public} \mbox{\hyperlink{struct_base_reader_handler}{BaseReaderHandler}}<UTF8<>, MessageHandler> \{}
\DoxyCodeLine{    \mbox{\hyperlink{struct_message_handler_a4f6165a34fa3a4de7021e7e5cd7fd4f6}{MessageHandler}}() : \mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}}(\mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca43d4b1361a039d9a3223b2407ed5b506}{kExpectObjectStart}}) \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_message_handler_a3d7e691831748287252e10ced02061f5}{StartObject}}() \{}
\DoxyCodeLine{        \textcolor{keywordflow}{switch} (\mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}}) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{case} \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca43d4b1361a039d9a3223b2407ed5b506}{kExpectObjectStart}}:}
\DoxyCodeLine{            \mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}} = \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca70008d18048772c50a2226a6e592c7db}{kExpectNameOrObjectEnd}};}
\DoxyCodeLine{            \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{        \textcolor{keywordflow}{default}:}
\DoxyCodeLine{            \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_message_handler_ab9de0f0bd0666b805563cb3f86ef3fc0}{String}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool}) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{switch} (\mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}}) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{case} \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca70008d18048772c50a2226a6e592c7db}{kExpectNameOrObjectEnd}}:}
\DoxyCodeLine{            \mbox{\hyperlink{struct_message_handler_a7a61cf6c752b8829eb9c058341617c69}{name\_}} = string(str, length);}
\DoxyCodeLine{            \mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}} = \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca6f46eb7d062c953ecb1a28a471908568}{kExpectValue}};}
\DoxyCodeLine{            \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{        \textcolor{keywordflow}{case} \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca6f46eb7d062c953ecb1a28a471908568}{kExpectValue}}:}
\DoxyCodeLine{            \mbox{\hyperlink{struct_message_handler_a628b5a49349a2027c84ffb4f6249fa51}{messages\_}}.insert(MessageMap::value\_type(\mbox{\hyperlink{struct_message_handler_a7a61cf6c752b8829eb9c058341617c69}{name\_}}, \textcolor{keywordtype}{string}(str, length)));}
\DoxyCodeLine{            \mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}} = \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca70008d18048772c50a2226a6e592c7db}{kExpectNameOrObjectEnd}};}
\DoxyCodeLine{            \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{        \textcolor{keywordflow}{default}:}
\DoxyCodeLine{            \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_message_handler_ab423864fd5ca806d4211c03acbdad67b}{EndObject}}(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}}) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}} == \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca70008d18048772c50a2226a6e592c7db}{kExpectNameOrObjectEnd}}; \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_message_handler_a3ab79ae50d26d5b3fb62a9bab58c21bb}{Default}}() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \} \textcolor{comment}{// All other events are invalid.}}
\DoxyCodeLine{}
\DoxyCodeLine{    \mbox{\hyperlink{messagereader_8cpp_ae2c5980b5eb04369faa7f72447e6d664}{MessageMap}} \mbox{\hyperlink{struct_message_handler_a628b5a49349a2027c84ffb4f6249fa51}{messages\_}};}
\DoxyCodeLine{    \textcolor{keyword}{enum} \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2c}{State}} \{}
\DoxyCodeLine{        \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca43d4b1361a039d9a3223b2407ed5b506}{kExpectObjectStart}},}
\DoxyCodeLine{        \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca70008d18048772c50a2226a6e592c7db}{kExpectNameOrObjectEnd}},}
\DoxyCodeLine{        \mbox{\hyperlink{struct_message_handler_a704e2a1bc5f7a4644998112cba61db2ca6f46eb7d062c953ecb1a28a471908568}{kExpectValue}},}
\DoxyCodeLine{    \}\mbox{\hyperlink{struct_message_handler_a927d3ae4618ed37e3904ff673fdd3768}{state\_}};}
\DoxyCodeLine{    std::string \mbox{\hyperlink{struct_message_handler_a7a61cf6c752b8829eb9c058341617c69}{name\_}};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} ParseMessages(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* json, \mbox{\hyperlink{messagereader_8cpp_ae2c5980b5eb04369faa7f72447e6d664}{MessageMap}}\& messages) \{}
\DoxyCodeLine{    \mbox{\hyperlink{class_generic_reader}{Reader}} reader;}
\DoxyCodeLine{    \mbox{\hyperlink{struct_message_handler}{MessageHandler}} handler;}
\DoxyCodeLine{    \mbox{\hyperlink{struct_generic_string_stream}{StringStream}} ss(json);}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (reader.\mbox{\hyperlink{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}{Parse}}(ss, handler))}
\DoxyCodeLine{        messages.swap(handler.\mbox{\hyperlink{struct_message_handler_a628b5a49349a2027c84ffb4f6249fa51}{messages\_}});   \textcolor{comment}{// Only change it if success.}}
\DoxyCodeLine{    \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{        \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga8d4b32dfc45840bca189ade2bbcb6ba7}{ParseErrorCode}} e = reader.\mbox{\hyperlink{class_generic_reader_a937bf90919f50e1c370b312cee5833e8}{GetParseErrorCode}}();}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} o = reader.\mbox{\hyperlink{class_generic_reader_ae9008523ccd06d839a57335835cb4091}{GetErrorOffset}}();}
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"{}Error: "{}} << \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga28835eb93d2c3c07bbea13515eb31415}{GetParseError\_En}}(e) << endl;;}
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"{} at offset "{}} << o << \textcolor{stringliteral}{"{} near '"{}} << string(json).substr(o, 10) << \textcolor{stringliteral}{"{}...'"{}} << endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{_c_make_c_compiler_id_8c_a0ddf1224851353fc92bfbff6f499fa97}{main}}() \{}
\DoxyCodeLine{    \mbox{\hyperlink{messagereader_8cpp_ae2c5980b5eb04369faa7f72447e6d664}{MessageMap}} messages;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* json1 = \textcolor{stringliteral}{"{}\{ \(\backslash\)"{}greeting\(\backslash\)"{} : \(\backslash\)"{}Hello!\(\backslash\)"{}, \(\backslash\)"{}farewell\(\backslash\)"{} : \(\backslash\)"{}bye-\/bye!\(\backslash\)"{} \}"{}};}
\DoxyCodeLine{    cout << json1 << endl;}
\DoxyCodeLine{    ParseMessages(json1, messages);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (MessageMap::const\_iterator itr = messages.begin(); itr != messages.end(); ++itr)}
\DoxyCodeLine{        cout << itr-\/>first << \textcolor{stringliteral}{"{}: "{}} << itr-\/>second << endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    cout << endl << \textcolor{stringliteral}{"{}Parse a JSON with invalid schema."{}} << endl;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* json2 = \textcolor{stringliteral}{"{}\{ \(\backslash\)"{}greeting\(\backslash\)"{} : \(\backslash\)"{}Hello!\(\backslash\)"{}, \(\backslash\)"{}farewell\(\backslash\)"{} : \(\backslash\)"{}bye-\/bye!\(\backslash\)"{}, \(\backslash\)"{}foo\(\backslash\)"{} : \{\} \}"{}};}
\DoxyCodeLine{    cout << json2 << endl;}
\DoxyCodeLine{    ParseMessages(json2, messages);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\{ "{}greeting"{} : "{}Hello!"{}, "{}farewell"{} : "{}bye-\/bye!"{} \}}
\DoxyCodeLine{farewell: bye-\/bye!}
\DoxyCodeLine{greeting: Hello!}
\DoxyCodeLine{}
\DoxyCodeLine{Parse a JSON with invalid schema.}
\DoxyCodeLine{\{ "{}greeting"{} : "{}Hello!"{}, "{}farewell"{} : "{}bye-\/bye!"{}, "{}foo"{} : \{\} \}}
\DoxyCodeLine{Error: Terminate parsing due to Handler error.}
\DoxyCodeLine{ at offset 59 near '\} \}...'}

\end{DoxyCode}


第一个 JSON（{\ttfamily json1}）被成功地解析至 {\ttfamily Message\+Map}。由于 {\ttfamily Message\+Map} 是一个 {\ttfamily std\+::map}，打印次序按键值排序。此次序与 JSON 中的次序不同。

在第二个 JSON（{\ttfamily json2}）中，{\ttfamily foo} 的值是一个空 object。由于它是一个 object，{\ttfamily \mbox{\hyperlink{struct_message_handler_a3d7e691831748287252e10ced02061f5}{Message\+Handler\+::\+Start\+Object()}}} 会被调用。然而，在 {\ttfamily state\+\_\+ = k\+Expect\+Value} 的情况下，该函数会返回 {\ttfamily false}，并导致解析过程终止。错误代码是 {\ttfamily k\+Parse\+Error\+Termination}。\hypertarget{md_src_rapidjson_doc_sax_zh_cn_Filtering}{}\doxysubsection{Filtering of JSON}\label{md_src_rapidjson_doc_sax_zh_cn_Filtering}
如前面提及过，{\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 可处理 {\ttfamily Reader} 发出的事件。{\ttfamily \mbox{\hyperlink{condense_8cpp}{example/condense/condense.\+cpp}}} 例子简单地设置 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}} 作为一个 {\ttfamily Reader} 的处理器，因此它能移除 JSON 中的所有空白字符。{\ttfamily \mbox{\hyperlink{pretty_8cpp}{example/pretty/pretty.\+cpp}}} 例子使用同样的关系，只是以 {\ttfamily \mbox{\hyperlink{class_pretty_writer}{Pretty\+Writer}}} 取代 {\ttfamily \mbox{\hyperlink{class_writer}{Writer}}}。因此 {\ttfamily pretty} 能够重新格式化 JSON，加入缩进及换行。

实际上，我们可以使用 SAX 风格 API 去加入（多个）中间层去过滤 JSON 的内容。例如 {\ttfamily capitalize} 例子可以把所有 JSON string 改为大写。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{reader_8h}{rapidjson/reader.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{writer_8h}{rapidjson/writer.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{filereadstream_8h}{rapidjson/filereadstream.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{filewritestream_8h}{rapidjson/filewritestream.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{en_8h}{rapidjson/error/en.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespacerapidjson}{rapidjson}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OutputHandler>}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{struct_capitalize_filter}{CapitalizeFilter}} \{}
\DoxyCodeLine{    \mbox{\hyperlink{struct_capitalize_filter_afe978f33a2f30a84a9e69cc91fe2da6d}{CapitalizeFilter}}(OutputHandler\& out) : \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}(out), \mbox{\hyperlink{struct_capitalize_filter_a6e05d2941c11423da2dbb3ab8eb2367d}{buffer\_}}() \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a8638839428a447d47711a4b367dc13a4}{Null}}() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Null(); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a957038be10025563a35ad32ab9d78418}{Bool}}(\textcolor{keywordtype}{bool} b) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Bool(b); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a5eec489885ed7f982ea66caf8d557210}{Int}}(\textcolor{keywordtype}{int} i) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Int(i); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a0e1d475eec0129d65fd7b2c06878e445}{Uint}}(\textcolor{keywordtype}{unsigned} u) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Uint(u); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a5ab3ec8eba2a56f595bf10e2f63c0446}{Int64}}(\mbox{\hyperlink{stdint_8h_a414156feea104f8f75b4ed9e3121b2f6}{int64\_t}} i) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Int64(i); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a603a8c709c0009d7b21dbb20a570bac7}{Uint64}}(\mbox{\hyperlink{stdint_8h_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}} u) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Uint64(u); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a1c21df7948456b3ae679db9d1a190249}{Double}}(\textcolor{keywordtype}{double} d) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.Double(d); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a471c199da18ca411550e703a6256abd8}{RawNumber}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.RawNumber(str, length, copy); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a9888a3eadb5297cc06b76df470767b48}{String}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool}) \{ }
\DoxyCodeLine{        \mbox{\hyperlink{struct_capitalize_filter_a6e05d2941c11423da2dbb3ab8eb2367d}{buffer\_}}.clear();}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} i = 0; i < length; i++)}
\DoxyCodeLine{            \mbox{\hyperlink{struct_capitalize_filter_a6e05d2941c11423da2dbb3ab8eb2367d}{buffer\_}}.push\_back(std::toupper(str[i]));}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.String(\&\mbox{\hyperlink{struct_capitalize_filter_a6e05d2941c11423da2dbb3ab8eb2367d}{buffer\_}}.front(), length, \textcolor{keyword}{true}); \textcolor{comment}{// true = output handler need to copy the string}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_ab21677e0794b7414ff0fec27f6599095}{StartObject}}() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.StartObject(); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_abe3c83f43cbb9ff7ff0e5fdabee79b21}{Key}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} length, \textcolor{keywordtype}{bool} copy) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a9888a3eadb5297cc06b76df470767b48}{String}}(str, length, copy); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_aea1d83e92b986264e04314ea2259207d}{EndObject}}(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} memberCount) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.EndObject(memberCount); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_ac6c50b5828bb848fbc98b92c2f432e9f}{StartArray}}() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.StartArray(); \}}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} \mbox{\hyperlink{struct_capitalize_filter_a3d7092e115d0b3f0a277da8487eff4d4}{EndArray}}(\mbox{\hyperlink{rapidjson_8h_a5ed6e6e67250fadbd041127e6386dcb5}{SizeType}} elementCount) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}}.EndArray(elementCount); \}}
\DoxyCodeLine{}
\DoxyCodeLine{    OutputHandler\& \mbox{\hyperlink{struct_capitalize_filter_a76bff3d685698cd6ab2e4cbb84bbf011}{out\_}};}
\DoxyCodeLine{    std::vector<char> \mbox{\hyperlink{struct_capitalize_filter_a6e05d2941c11423da2dbb3ab8eb2367d}{buffer\_}};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{_c_make_c_compiler_id_8c_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char}*[]) \{}
\DoxyCodeLine{    \textcolor{comment}{// Prepare JSON reader and input stream.}}
\DoxyCodeLine{    \mbox{\hyperlink{class_generic_reader}{Reader}} reader;}
\DoxyCodeLine{    \textcolor{keywordtype}{char} readBuffer[65536];}
\DoxyCodeLine{    \mbox{\hyperlink{class_file_read_stream}{FileReadStream}} is(stdin, readBuffer, \textcolor{keyword}{sizeof}(readBuffer));}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Prepare JSON writer and output stream.}}
\DoxyCodeLine{    \textcolor{keywordtype}{char} writeBuffer[65536];}
\DoxyCodeLine{    \mbox{\hyperlink{class_file_write_stream}{FileWriteStream}} os(stdout, writeBuffer, \textcolor{keyword}{sizeof}(writeBuffer));}
\DoxyCodeLine{    \mbox{\hyperlink{class_writer}{Writer<FileWriteStream>}} writer(os);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// JSON reader parse from the input stream and let writer generate the output.}}
\DoxyCodeLine{    \mbox{\hyperlink{struct_capitalize_filter}{CapitalizeFilter<Writer<FileWriteStream>}} > filter(writer);}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (!reader.\mbox{\hyperlink{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}{Parse}}(is, filter)) \{}
\DoxyCodeLine{        fprintf(stderr, \textcolor{stringliteral}{"{}\(\backslash\)nError(\%u): \%s\(\backslash\)n"{}}, (\textcolor{keywordtype}{unsigned})reader.\mbox{\hyperlink{class_generic_reader_ae9008523ccd06d839a57335835cb4091}{GetErrorOffset}}(), \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga28835eb93d2c3c07bbea13515eb31415}{GetParseError\_En}}(reader.\mbox{\hyperlink{class_generic_reader_a937bf90919f50e1c370b312cee5833e8}{GetParseErrorCode}}()));}
\DoxyCodeLine{        \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}


注意到，不可简单地把 JSON 当作字符串去改为大写。例如： 
\begin{DoxyCode}{0}
\DoxyCodeLine{["{}Hello\(\backslash\)nWorld"{}]}

\end{DoxyCode}


简单地把整个 JSON 转为大写的话会产生错误的转义符： 
\begin{DoxyCode}{0}
\DoxyCodeLine{["{}HELLO\(\backslash\)NWORLD"{}]}

\end{DoxyCode}


而 {\ttfamily capitalize} 就会产生正确的结果： 
\begin{DoxyCode}{0}
\DoxyCodeLine{["{}HELLO\(\backslash\)nWORLD"{}]}

\end{DoxyCode}


我们还可以开发更复杂的过滤器。然而，由于 SAX 风格 API 在某一时间点只能提供单一事件的信息，使用者需要自行记录一些上下文信息（例如从根节点起的路径、储存其他相关值）。对于处理某些情况，用 DOM 会比 SAX 更容易实现。 